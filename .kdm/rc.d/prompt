# Functions: PS1 prompt

[[ "${_}" != "${0}" && "${SOURCE_VERBOSE}" == "true" ]] && output kv "Loaded" "${BASH_SOURCE[@]/$HOME\/\.kdm\//}"


# Debug only because of this rediculous stupid thing i've accidentally built here
_prompt_log() {
	return

	[[ -z "${PROMPT_LOG_PREFIX}" ]] && PROMPT_LOG_PREFIX="0"

	if [[ "${2}" == *"END"* ]]; then
		((PROMPT_LOG_PREFIX--))
	fi

	# echo "[$(date '+%r')] [${PROMPT_LOG_PREFIX}/${BASH_SUBSHELL}] $(printf '%*s' ${PROMPT_LOG_PREFIX} '' | sed 's/\ /\t/g') $(printf '%s' "${1}")() :: ${2}" >> ~/kdm-prompt.log
	echo "[$(date '+%r')] [${PROMPT_LOG_PREFIX}/${BASH_SUBSHELL}] $(printf '%*s' ${BASH_SUBSHELL} '' | sed 's/\ /\t/g') $(printf '%s' "${1}")() :: ${2}" >> ~/kdm-prompt.log

	if [[ "${2}" == *"START"* ]]; then
		((PROMPT_LOG_PREFIX++))
	fi

	export PROMPT_LOG_PREFIX
}

# Debug only
_prompt_tst() {
	# env | grep -Ei '\/Users\/kdm|code|~' | grep -Ev 'BASH_ENV_|GOPATH|DIR_MS|DIR_ED|DIR_HOME_|HISTFILE|DIR_LGT|DIR_ME|CURL_HOME|LESSOP|MIBDIRS|PATH=|PIP_CONFIG|HTML_TIDY|C_CODE=|PROMPT_COMMAND=|TY_FRMU|XPC_SERVICE' | grep -Ei '\/Users\/kdm|code|~' | sort
	_prompt_log "${FUNCNAME[0]}" "OLDPWD=${OLDPWD}"
	_prompt_log "${FUNCNAME[0]}" "PS1=${PS1}"
	_prompt_log "${FUNCNAME[0]}" "PWD=${PWD}"
	_prompt_log "${FUNCNAME[0]}" "PWD_FINAL=${PWD_FINAL}"
	_prompt_log "${FUNCNAME[0]}" "PWD_FMT=${PWD_FMT}"
	_prompt_log "${FUNCNAME[0]}" "PWD_FMT_LAST=${PWD_FMT_LAST}"
}


# Generate / export PS1 prompt with color specfied by C_ENV
_prompt_generate() {
	# _prompt_log "${FUNCNAME[0]}" "START"

	# Return if we're not in a terminal
	[[ "${BASH_INTERACTIVE}" ]] || return

	# Load data from environment.. hopefully.. this time..
	if [[ -z "${COLOR_16M}" ]]; then
		COLOR_16M="false"

		[[ "${COLORTERM}"  == "truecolor" ]] && COLOR_16M="true"
		[[ "${TERM_COLOR}" == "16m"       ]] && COLOR_16M="true"

		export COLOR_16M
	fi

	# If connected via SSH, display prompt hostname
	if [[ -z "${PROMPT_HOSTNAME}" ]]; then
		PROMPT_HOSTNAME="false"

		[[ -z "${SSH_CLIENT+x}"     ]] || PROMPT_HOSTNAME="true"
		[[ -z "${SSH_CONNECTION+x}" ]] || PROMPT_HOSTNAME="true"
		[[ -z "${SSH_TTY+x}"        ]] || PROMPT_HOSTNAME="true"

		export PROMPT_HOSTNAME
	fi

	# Kick _prompt_pwd again with no output to export environment variables
	_prompt_pwd > /dev/null 2>&1

	# If $BASH_ENV_COLOR_16M is not true, render PS1 without multicolor
	if [[ "${COLOR_16M}" != "true" ]]; then
		PS1="\\[\\e[G\\]\\[${C_ENV}\\]\${HOST_SHORT}\\[${C_RST}\\]:\\[${C_BLU}\\]${PWD_FINAL} \\[${C_ENV}\\]\\$\\[${C_RST}\\] "
		export PS1
		return
	fi

	# Re-render truecolor PS1 prompt if PWD has changed
	[[ "${PWD_UPDATED}" == "true" ]] && _prompt_pwd_color_render "${PWD_FINAL}"

	# If PROMPT_HOSTNAME is false, render PS1 without hostname
	if [[ "${PROMPT_HOSTNAME}" == "false" ]]; then
		PS1="\\[\\e[G\\]\\[${C_BLU}\\]${PS1_COLOR} \\[${C_ENV}\\]\\$\\[${C_RST}\\] "
		export PS1

		# _prompt_log "${FUNCNAME[0]}" "END"
		return
	fi

	# Normal PS1 prompt (with hostname)
	PS1="\\[\\e[G\\]\\[${C_ENV}\\]\${HOST_SHORT}\\[${C_RST}\\]:\\[${C_BLU}\\]${PS1_COLOR} \\[${C_ENV}\\]\\$\\[${C_RST}\\] "
	export PS1

	# It would be neat to do a color-responsive system load monitor... but not today

	# _prompt_log "${FUNCNAME[0]}" "END"
} # _prompt_generate()

# Print colorized exit code information
_prompt_exitcode() {
	# _prompt_log "${FUNCNAME[0]}" "START"

	# Declare vars as local
	local ARRAY_CMD CMD ENV GRY RED STR WHT YLW

	# Return if we're not in a terminal
	[[ "${BASH_INTERACTIVE}" ]] || return

	# Bounce if no arguments passed
	[[ -z "${1}" || -z "${2}" ]] && return

	# Bounce if exit code is one of:
	#   0 : command OK
	# 127 : BASH command not found
	# 253 : kdm-bash-env command noop
	# 254 : kdm-bash-env command noop
	case "${2}" in
		0)   return ;;
		127) return ;;
		253) return ;;
		254) return ;;
	esac

	# Bounce if command name is one of:
	#      _g_* : kdm-bash-env git wrapper command
	# _prompt_* : kdm-bash-env prompt command
	#
	# cd, grep, history, or sourcing a file
	ARRAY_CMD=("${1}")
	case "${ARRAY_CMD[0]}" in
		_g_*)         return ;;
		_prompt_*)    return ;;
		_show_clock*) return ;;

		cd)   return ;;
		grep) return ;;

		history) return ;;

		.)      CMD="${ARRAY_CMD[0]} ${ARRAY_CMD[1]}" ;;
		source) CMD="${ARRAY_CMD[0]} ${ARRAY_CMD[1]}" ;;

		*) CMD="${ARRAY_CMD[0]}" ;;
	esac

	STR="%s${C_RST}"

	ENV="${C_ENV}${STR}"
	GRY="${C_GRY}${STR}"
	RED="${C_RED_BRT_BLD}${STR}"
	WHT="${C_WHT_BRT}${STR}"
	YLW="${C_YLW}${STR}"

	ARRAY_CMD=("${1}")
	printf "${GRY} ${RED} ${WHT} ${GRY}\\n" "${CMD}" "failed" ":" "${2}"

	# _prompt_log "${FUNCNAME[0]}" "END"
} # _prompt_exitcode()

# Print exit code right-aligned for the PS1 prompt
_prompt_right() {
	# _prompt_log "${FUNCNAME[0]}" "START"

	# Declare vars as local
	local CLR TRIM

	# Set color based on exit code
	case "${1}" in
		0) CLR="${C_GRN}" ;;
		*) CLR="${C_ALT}" ;;
	esac

	# Trim off 2+length of 1st argument
	TRIM="${#1}"; ((TRIM++))
	printf "${C_GRY}%*s${CLR}%s${C_RST}${C_GRY}%s${C_RST}\\r" "$((COLUMNS-TRIM))" "[" "${1}" "]"

	# _prompt_log "${FUNCNAME[0]}" "END"
} # _prompt_right()

_prompt_pwd() {
	# _prompt_log "${FUNCNAME[0]}" "START"

	# Get the current directory, swap out the home directory with a tilde
	PWD_FMT="${PWD/${HOME}/\~}"

	# Sometimes older bash versions get weird with the above substring replacement
	# shellcheck disable=SC1003
	if echo "${PWD_FMT}" | grep -Eq '\\'; then
		PWD_FMT="${PWD/${HOME}/~}"
	fi

	# _prompt_log "${FUNCNAME[0]}" "PWD_FMT_LAST=${PWD_FMT_LAST}"

	# Skip if the PWD hasn't changed
	if [[ "${PWD_FMT}" == "${PWD_FMT_LAST}" ]]; then
		export PWD_UPDATED="false"

		# _prompt_log "${FUNCNAME[0]}" "export PWD_UPDATED=${PWD_UPDATED}"
		# _prompt_log "${FUNCNAME[0]}" "END"
		return
	fi

	export PWD_UPDATED="true"
	# _prompt_log "${FUNCNAME[0]}" "export PWD_UPDATED=${PWD_UPDATED}"

	export PWD_FMT
	# _prompt_log "${FUNCNAME[0]}" "export PWD_FMT=${PWD_FMT}"

	export PWD_FMT_LAST="${PWD_FMT}"
	# _prompt_log "${FUNCNAME[0]}" "export PWD_FMT_LAST=${PWD_FMT_LAST}"


	# Here we modify the pwd string to shorten the display
	# Find how many folders deep we are
	PWD_FMT_DEPTH="$(echo "${PWD_FMT}" | awk -F '/' '{print NF-1}')"
	export PWD_FMT_DEPTH

	# If we're LESS than 3 folders deep, pwd for titlebar and prompt is normal
	# If we're MORE than 3 folders deep, show ../previous_dir/current_dir
	PWD_CUSTOM=$(printf "${PWD_FMT}" | rev | awk -F '/' '{printf $1"/"$2"/.."}' | rev)

	[[ "${PWD_FMT_DEPTH}" -lt "3" ]] && PWD_FINAL="${PWD_FMT}" || PWD_FINAL="${PWD_CUSTOM}"
	export PWD_FINAL
	# _prompt_log "${FUNCNAME[0]}" "export PWD_FINAL=${PWD_FINAL}"

	# _prompt_log "${FUNCNAME[0]}" "END"
} # _prompt_pwd()


# Render color-separated formatted pwd
# shellcheck disable=SC2206
_prompt_pwd_color_render() {
	# _prompt_log "${FUNCNAME[0]}" "START"

	# Declare vars as local
	local OLDIFS IFS INPUT DIRS SEPARATORS DEPTH COUNT STR RST CYN BLU YLW GRY PRP

	# Escape color sequences for PS1 compatiblity
	RST="\\[${C_RST}\\]"
	CYN="\\[${C_CYN}\\]"
	BLU="\\[${C_BLU_BRT_BLD}\\]"
	YLW="\\[${C_YLW}\\]"
	GRY="\\[${C_GRY}\\]"
	PRP="\\[${C_PRP}\\]"

	# Color configuration
	DIRS[0]="${CYN}"
	DIRS[1]="${BLU}"

	SEPARATORS[0]="${YLW}.."
	SEPARATORS[1]="${GRY}/"
	SEPARATORS[2]="${PRP}~"

	# Set separator to forward slash
	OLDIFS="${IFS}"
	IFS='/'

	# Render input PATH into array by temporarily disabling glob expansion
	# ($@) is deliberately unquoted
	set -f; INPUT=($@); set +f
	# _prompt_log "${FUNCNAME[0]}" "INPUT=${INPUT[*]}"

	# Reset separator
	IFS="${OLDIFS}"

	# Init loop cariables
	DEPTH="${#INPUT[@]}"
	COUNT="0"
	STR=""

	# Special color coding for certain leading characters
	case "${INPUT[0]}" in
		'..') STR+="${SEPARATORS[0]}" ;;
		'~')  STR+="${SEPARATORS[2]}" ;;
	esac

	# Add a slash if we're in / directory
	[[ "${*}"      == "/" ]] && STR+="${SEPARATORS[1]}"
	# Add a slash if we're somewhere more than 1 dir deep
	[[ "${DEPTH}" -gt "1" ]] && STR+="${SEPARATORS[1]}"
	((COUNT++))

	# Add color to path elements
	INPUT[1]="${DIRS[0]}${INPUT[1]}"
	INPUT[2]="${DIRS[1]}${INPUT[2]}"

	# Concatenate color-formatted string
	while [[ "${COUNT}" != "${DEPTH}" ]]; do
		STR+="${INPUT[$COUNT]}"
		((COUNT++))

		# Append a trailing slash if proper to do so
		[[ "${COUNT}" != "${DEPTH}" ]] && STR+="${SEPARATORS[1]}"
	done

	STR+="${RST}"
	# _prompt_log "${FUNCNAME[0]}" "STR=${STR}"

	# Print the color-formatted string
	PS1_COLOR="$(printf "%s" "${STR}")"
	export PS1_COLOR
	# _prompt_log "${FUNCNAME[0]}" "export PS1_COLOR=${PS1_COLOR}"

	# _prompt_log "${FUNCNAME[0]}" "END"
} # _prompt_pwd_color_render()

_prompt_titlebar() {
	# _prompt_log "${FUNCNAME[0]}" "START"

	# Declare vars as local
	local TITLEBAR_SSH

	# Return if we're not in a terminal
	[[ "${BASH_INTERACTIVE}" ]] || return

	# Add '[SSH]' to titlebar if in SSH session
	[[ "${SSH_CONNECTION}" ]] && TITLEBAR_SSH="[SSH] "

	# Only apply custom titlebar if we're in xterm and on Bash 3+
	[[ "${TERM}" == *"xterm"* && "${BASH_VERSINFO[0]}" -ge "3" ]] && printf "\\033]0;%s%s\\007" "${TITLEBAR_SSH}" "${HOST_SUB}:${PWD_FINAL}"

	# _prompt_log "${FUNCNAME[0]}" "END"
} # _prompt_titlebar()


# Configure PS1 prompt
# _prompt_generate


# vim: set filetype=sh ts=2 sw=2 tw=0 noet :
