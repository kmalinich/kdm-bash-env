# Functions: Text

[[ "${_}" != "${0}" && "${SOURCE_VERBOSE}" == "true" ]] && output keyval "Loaded" "${BASH_SOURCE[@]/$HOME\/\.kdm\//}"


# Output formatted text
# I would have used an associative array (and in one version, I did),
# but it's only in bash 4+ which is ... more rarely seen than I'd like
output() {
	# Declare vars as local
	local COLOR_SELECTED OUTPUT_FORMAT OUTPUT_STDERR OUTPUT_STRING

	# Case statement for output color/format
	case "${1,,}" in
		# Basic colors
		a|alert)       COLOR_SELECTED="${C_ALT}";;
		blk|black)     COLOR_SELECTED="${C_BLK}";;
		blu|blue)      COLOR_SELECTED="${C_BLU}";;
		c|cyn|cyan)    COLOR_SELECTED="${C_CYN}";;
		gry|gray)      COLOR_SELECTED="${C_GRY}";;
		grn|green)     COLOR_SELECTED="${C_GRN}";;
		o|orn|orange)  COLOR_SELECTED="${C_ORN}";;
		pk|pnk|pink)   COLOR_SELECTED="${C_PNK}";;
		pr|prp|purple) COLOR_SELECTED="${C_PRP}";;
		r|red)         COLOR_SELECTED="${C_RED}";;
		w|wht|white)   COLOR_SELECTED="${C_WHT}";;
		y|ylw|yellow)  COLOR_SELECTED="${C_YLW}";;

		b|backtick)
			# Output the input string with backticks (for Slack, mainly)
			OUTPUT_FORMAT="${C_CODE}${C_BLD}\`%s\`${C_RST}\\n"

			# Copy string to clipboard if not connected via SSH and binary is present
			[[ -z "${SSH_CONNECTION}" ]] && hash pbcopy && printf "\`%s\`" "${2}" | pbcopy
			output stderr "Copied string to clipboard"
			;;

		e|error)
			# Special function to output formatted usage string, with stderr output
			OUTPUT_FORMAT="${C_RED_BRT_BLD}${C_ITA}Error${C_RST} ${C_WHT_BRT}:${C_RST} ${C_RED}%s${C_RST}\\n"
			OUTPUT_STDERR="1>&2"
			;;

		ef|error_fail)
			# Special function to output formatted usage string, with stderr output
			OUTPUT_FORMAT="${C_RED_BRT_BLD}${C_ITA}Error${C_RST} ${C_WHT_BRT}:${C_RST} ${C_RED}Failed %s, cannot continue${C_RST}\\n"
			OUTPUT_STDERR="1>&2"
			;;

		f|failure)
			# Special function for failure message, no string input
			COLOR_SELECTED="${C_RED_BRT_BLD}"
			OUTPUT_STRING="failure"
			;;

		k|kv|keyval)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_YLW}%s${C_GRY}'${C_RST}\\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		kb|kvb|keyval-b)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_BLU}%s${C_GRY}'${C_RST}\\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		kc|kvc|keyval-c)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_CYN}%s${C_GRY}'${C_RST}\\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		kf|kvf|keyval-f|kr|kvr|keyval-r)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_RED}%s${C_GRY}'${C_RST}\\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		ko|kvo|keyval-o)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_ORN}%s${C_GRY}'${C_RST}\\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		kp|kvp|keyval-p)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_PRP}%s${C_GRY}'${C_RST}\\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		kt|kvt|keyval-t)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_GRN}%s${C_GRY}'${C_RST}\\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		l|lu|leadup) # Special function for leadup to status message, no newline
			# Create dot string and output format
			printf -v LOADING_DOT_STRING '%*s' $((70-${#2}-${#3})) ''
			OUTPUT_FORMAT="${C_RST}Performing ${C_GRY}'${C_ORN_BRT}%s${C_GRY}'${C_RST} ${C_WHT_BRT}$(printf '%s' "${LOADING_DOT_STRING// /.}") ${C_RST}"
			;;

		lc|luc|leadup-custom) # Special function for leadup to status message, no newline, with custom command name
			# Check for 2nd and 3rd args
			[[ -z "${2}" || -z "${3}" ]] && output usage "${USAGE_STRING}" && return
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			# Create dot string and output format
			printf -v LOADING_DOT_STRING '%*s' $((70-${#2}-${#3})) ''
			OUTPUT_FORMAT="${C_RST}%s ${C_GRY}'${C_ORN_BRT}%s${C_GRY}'${C_RST} ${C_WHT_BRT}$(printf '%s' "${LOADING_DOT_STRING// /.}") ${C_RST}"

			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		2|se|stderr)
			# Special function to output to stderr
			COLOR_SELECTED="${C_BLU}"
			OUTPUT_STDERR="1>&2"
			;;

		s|success)
			# Special function for success message, no string
			COLOR_SELECTED="${C_GRN_BLD}"
			OUTPUT_STRING="success"
			;;

		u|usg|usage)
			# Special function to output formatted usage string, with stderr output
			OUTPUT_FORMAT="${C_YLW_BLD}${C_ITA}Usage${C_RST} ${C_WHT_BRT}:${C_RST} %s\\n"
			OUTPUT_STDERR="1>&2"
			;;

		*) COLOR_SELECTED="${C_RST}";; # If nothing matches, reset color
	esac

	# Check for variables and throw usage message if issue
	if [[ -z "${OUTPUT_STRING-${2}}" ]]; then
		_output_usage
		return
	fi

	# Finalize vars
	OUTPUT_FORMAT="${OUTPUT_FORMAT-${COLOR_SELECTED}%s${C_RST}\n}"
	OUTPUT_STRING="${OUTPUT_STRING-${2}}"

	# Output to stdout or stderr based on switch
	[[ "${OUTPUT_STDERR}" ]] && printf "${OUTPUT_FORMAT}" "${OUTPUT_STRING}" 1>&2 && return
	printf "${OUTPUT_FORMAT}" "${OUTPUT_STRING}"
}

# Function "alias" for use in scripts
function o() {
	output "${@}"
}

_output_usage() {
	# Declare vars as local
	local ARRAY_USAGE

	# Array of arrays options
	declare -A ARRAY_USAGE='(
	[0]="alert error error_fail usage"
	[1]="black blue orange cyan gray green orange pink purple red white yellow"
	[2]="leadup leadup-custom"
	[3]="failure success"
	[4]="keyval keyval-b keyval-c keyval-f keyval-o keyval-p keyval-r keyval-t"
	[5]="backtick stderr"
	)'

	output usage "output <format> <string 1> [<string 2, for keyval options>]"; echo
	output text  "Format : < ${ARRAY_USAGE[0]} >"
	output text  "         < ${ARRAY_USAGE[1]} >"
	output text  "         < ${ARRAY_USAGE[2]} >"
	output text  "         < ${ARRAY_USAGE[3]} >"
	output text  "         < ${ARRAY_USAGE[4]} >"
	output text  "         < ${ARRAY_USAGE[5]} >"
}


# bash tab-completion for output function
_output_completion() {
	# Declare vars as local
	local ARRAY_USAGE_OPTIONS CUR_WORD

	# Array of options
	ARRAY_USAGE_OPTIONS=(
	alert error error_fail usage

	black blue cyan gray green orange pink purple red white yellow

	leadup leadup-custom

	failure success

	keyval keyval-b keyval-c keyval-f keyval-o keyval-p keyval-r keyval-t

	backtick stderr
	)

	CUR_WORD=${COMP_WORDS[COMP_CWORD]}
	mapfile -t COMPREPLY < <(compgen -W "${ARRAY_USAGE_OPTIONS[*]}" -- "${CUR_WORD}")
}

# bash tab-completion for shortened o function
_o_completion() {
	# Declare vars as local
	local ARRAY_USAGE_OPTIONS CUR_WORD

	# Array of options
	ARRAY_USAGE_OPTIONS=(
	a e ef u

	blk blu c gry grn o pk pr r w y

	l lc

	f s

	k kb kc kf ko kp kr kt

	b 2
	)

	CUR_WORD=${COMP_WORDS[COMP_CWORD]}
	mapfile -t COMPREPLY < <(compgen -W "${ARRAY_USAGE_OPTIONS[*]}" -- "${CUR_WORD}")
}


# Configure/enable completion
complete -F _output_completion output
complete -F _o_completion      o



# vim: set syntax=sh filetype=sh ts=2 sw=2 tw=0 noet :
