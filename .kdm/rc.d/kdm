# Functions: kdm-bash-env

[[ "${_}" != "${0}" && "${SOURCE_VERBOSE}" == "true" ]] && output kv "Loaded" "${BASH_SOURCE[@]/$HOME\/\.kdm\//}"


# Get Git hash of bash-env
_kdm_hash() {
	# Declare vars as local
	local OLD_PWD

	OLD_PWD="${PWD}"
	cd "${HOME}" || return

	git log --pretty=format:'%h' -n 1
	cd "${OLD_PWD}" || return
}

# Help with/list bashrc functions
_kdm_help() {
	# Declare vars as local
	local BAR="${C_PRP}============${C_RST}"

	local ENV_CMD ENV_CMDS
	local ENV_CMD_GROUP_FMT ENV_CMD_GROUP_NEW ENV_CMD_GROUP_OLD

	mapfile -t ENV_CMDS < <(alias | grep -Ev 'CMD|ehco|grep|grpe|ls\ .*.\-\-|lsusb|md5sum|namp|pign|ping=|kk|vim|\.\.|showbin|ssh|sudo|tial|\-format=' | awk -F '[ =]' '{print $2}' | sed -r '/^.{,2}$/d')

	ENV_CMD_GROUP_OLD=""
	for ENV_CMD in "${ENV_CMDS[@]}"; do
		# Get 1st 3 letters of command
		ENV_CMD_GROUP_NEW="${ENV_CMD:0:3}"

		# If we've moved to a new group, add an extra newline
		if [[ "${ENV_CMD_GROUP_NEW}" != "${ENV_CMD_GROUP_OLD}" ]]; then
			ENV_CMD_GROUP_FMT="$(echo "${ENV_CMD:0:4}" | awk -F '-' '{printf $1}')"
			echo -e "\n\n${C_WHT_BRT}-${C_RST}${BAR}${BAR}${BAR} ${C_GRN_BRT}${ENV_CMD_GROUP_FMT}${C_RST} ${C_WHT_BRT}-${C_RST}"
		fi

		output keyval-o "Command" "${ENV_CMD}"

		ENV_CMD_GROUP_OLD="${ENV_CMD_GROUP_NEW}"
	done
}

# Quick-draw pull bash env
_kdm_pull() {
	# Declare vars as local
	local CMD_EXIT OLD_PWD

	# Save current PWD
	OLD_PWD="${PWD}"
	cd "${HOME}" || return 1

	_g_gu
	CMD_EXIT="${?}"

	cd "${OLD_PWD}" || return 1
	return ${CMD_EXIT}
}

# Re-source ${HOME}/.kdm/rc, then files in the 'source' dir
# shellcheck disable=SC1090
_kdm_source() {
	# Declare vars as local
	local OLD_PWD
	local SOURCE_CLR SOURCE_FILE SOURCE_MSG SOURCE_PATH

	OLD_PWD="${PWD}"
	cd "${BASH_ENV_DIR_KDM}" || return

	# Quiet output
	[[ "${1}" != "-q" ]] && export SOURCE_VERBOSE="true"

	for i in {0..23}; do
		SOURCE_FILE="$(printf '%02d' "${i}")"
		SOURCE_PATH="$(ls "profile.d/${SOURCE_FILE}"-*)"
		[[ ! -s "${SOURCE_PATH}" ]] && continue

		# Quiet output
		[[ "${1}" == "-q" ]] && . "${SOURCE_PATH}" && continue

		SOURCE_CLR="f"
		SOURCE_MSG="Failed"

		if . "${SOURCE_PATH}"; then
			SOURCE_CLR="t"
			SOURCE_MSG="Loaded"
		fi

		output "kv${SOURCE_CLR}" "${SOURCE_MSG}" "${SOURCE_PATH}"
	done

	# Quiet output
	[[ "${1}" != "-q" ]] && unset SOURCE_VERBOSE

	cd "${OLD_PWD}" || return
	unset OLD_PWD
}

# Get timestamp of last bash-env commit from Git
_kdm_time() {
	# Declare vars as local
	local DATE_CMD GIT_SEC OLD_PWD

	OLD_PWD="${PWD}"
	cd "${HOME}" || return

	# Last commit UNIX seconds-since-epoch timestamp
	GIT_SEC="$(git log -1 --date=short --pretty=format:%ct)"

	# macOS date command is different when translating from seconds-since-epoch to date if the GNU utils aren't installed
	DATE_CMD=(date)
	[[ "${MACOS_GNU}" || "${UNAME_KERNEL_NAME}" == "Linux" ]] && DATE_CMD+=("--date=@${GIT_SEC}") || DATE_CMD+=(-j -r "${GIT_SEC}")
	DATE_CMD+=('+%a %b %0d %r')

	"${DATE_CMD[@]}"

	cd "${OLD_PWD}" || return
}


# Update Git submodule, but detach and return immediately (or close to immediately)
_kdm_update_submodule() {
	# Declare vars as local
	local DIR_SUBMODULE SUBMODULE

	SUBMODULE="${1}"

	DIR_SUBMODULE="${HOME}/${SUBMODULE}"
	cd "${DIR_SUBMODULE}" || return 2

	{
		git fetch --all --prune
		git checkout master
		git pull --prune
	} > /dev/null 2>&1

	output keyval-y "[kdm-update][subm][${SUBMODULE}]" "pull"

	git gc --aggressive --prune > /dev/null 2>&1
	output keyval-y "[kdm-update][subm][${SUBMODULE}]" "garbage collection"
}

# Update all Git submodules for kdm-bash-env (in a parallel-ish fashion)
_kdm_update() {
	# Declare vars as local
	local ARRAY_SUBMODULES DIR_SUBMODULE SUBMODULE OLD_PWD WAIT_COUNT

	OLD_PWD="${PWD}"

	# Change to home directory
	if ! cd; then
		output error "Unable to change to home directory"
		return 1
	fi

	{
		git fetch --all --prune
		git pull        --prune
	} > /dev/null 2>&1

	output keyval-y "[kdm-update][main]" "pull"


	output keyval-y "[kdm-update][main]" "Begin submodule update"

	mapfile -t ARRAY_SUBMODULES < <(git submodule | awk '{print $2}')
	for SUBMODULE in "${ARRAY_SUBMODULES[@]}"; do
		_kdm_update_submodule "${SUBMODULE}" &
	done
	echo

	# Wait for Git processes to complete
	WAIT_COUNT="0"
	while pgrep -f 'git\ (checkout|fetch|gc|prune|pull|status|submodule)' > /dev/null 2>&1; do
		if [[ "${WAIT_COUNT}" -gt "120" ]]; then
			output error "Waiting for Git processes to complete took too long"
			return 6
		fi

		[[ "$((WAIT_COUNT%10))" == "0" ]] && output keyval-r "[kdm-update][main]" "Waited on submodule update for ${WAIT_COUNT} seconds"

		sleep 1

		((WAIT_COUNT++))
	done

	output keyval-g "[kdm-update][main]" "Submodule update complete"

	output keyval-y "[kdm-update][main]" "Garbage collection"
	git gc --aggressive --prune > /dev/null 2>&1

	output keyval-c "[kdm-update][main]" "Submodule status"
	git submodule
	echo

	output keyval-c "[kdm-update][main]" "Repo status"
	git status
	echo

	# Change back to original pwd
	if ! cd "${OLD_PWD}"; then
		output error "Unable to change back to old pwd '${OLD_PWD}'"
		return 9
	fi

	output keyval-g "[kdm-update][main]" "Complete"
	return 0
}


# Function aliases
alias kdm-hash='  _kdm_hash'
alias kdm-help='  _kdm_help'
alias kdm-pull='  _kdm_pull'
alias kdm-source='_kdm_source'
alias kdm-time='  _kdm_time'
alias kdm-update='_kdm_update'


# vim: set filetype=sh ts=2 sw=2 tw=0 noet :
