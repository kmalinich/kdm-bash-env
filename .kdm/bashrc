# kdm bash-env
# .kdm/bashrc


# Source global bashrc
# shellcheck disable=SC1091
[[ -f /etc/bash.bashrc ]] && . /etc/bash.bashrc
[[ -f /etc/bashrc      ]] && . /etc/bashrc


#### Aliases: Function names ==start ####

alias android-make-md5='_android_make_md5'

alias array-dedupe='_array_dedupe'
alias array-width='_array_width'

alias convert-squid-timestamp='_convert_squid_timestamp'
alias convert-temperature='_convert_temperature'

alias find-dir='_find_dir'
alias find-file='_find_file'
alias find-largest='_find_largest'

alias fix-bash-pids='_fix_bash_pids'
alias fix-hung-java='_fix_hung_java'
alias fix-macos-files='_fix_macos_files'

alias g-gca='_g_gca'
alias g-gi='_g_gi'
alias g-gpo='_g_gpo'
alias g-gs='_g_gs'
alias g-gsu='_g_gsu'
alias g-gu='_g_gu'

alias kdm-help='_kdm_help'
alias kdm-pull='_kdm_pull'
alias kdm-source='_kdm_source'

alias md5-clean='_md5_clean'
alias md5-compare='_md5_compare'

alias net-curl='_net_curl'
alias net-dns-lookup='_net_dns_lookup'
alias net-info='_net_info'
alias net-mac-lookup='_net_mac_lookup'
alias net-mac='_net_mac'
alias net-ping-average-csv='_net_ping_average_csv'
alias net-ping-average='_net_ping_average'
alias net-ping-subnet='_net_ping_subnet'
alias net-webserver='_net_webserver'

alias show-bin='_show_bin'
alias showbin='_show_bin'
alias show-clock='_show_clock'
alias show-motd='_show_motd'
alias show-scp-path='_show_scp_path'
alias show-top-cmds='_show_top_cmds'

alias ssh-c='_ssh_c'
alias ssh-ping='_ssh_ping'
alias ssh-x='_ssh_x'
alias ssh-xc='_ssh_xc'

alias time-elapsed-chrono='_time_elapsed_chrono'
alias time-elapsed-text='_time_elapsed_text'

alias update-all='_update_all'
alias update-cpan='_update_cpan'

#### Aliases: Function names ==final ####


#### Functions: Color ==start ####

# Renders a hex color code in 24bit color output, and generates the corresponding ANSI escape sequence
hex2color() {
	local USAGE_STRING="hex2color '#4e0d92'"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	# Remove leading hash mark if present
	COLOR_HEX="${1//\#/}"

	# Convert to decimal values
	DEC_VAL_1="$((0x${COLOR_HEX:0:2}))"
	DEC_VAL_2="$((0x${COLOR_HEX:2:2}))"
	DEC_VAL_3="$((0x${COLOR_HEX:4:2}))"

	# Render ANSI string
	ANSI_COLOR="[38;2;${DEC_VAL_1};${DEC_VAL_2};${DEC_VAL_3}m"

	# Output info and sample
	echo "#${COLOR_HEX} | ${DEC_VAL_1} ${DEC_VAL_2} ${DEC_VAL_3} | \\\e${ANSI_COLOR} | http://www.color-hex.com/color/${COLOR_HEX,,} | \e${ANSI_COLOR}TESTING color${C_RST}"
}

# Render RGB values into hex string, then feed to hex2color function
rgb2hex() {
	# Validate input
	local INPUT_ERRORS="0"
	[[ -z "${1}" ]] && output error "Missing 1st argument" && ((INPUT_ERRORS++))
	[[ -z "${2}" ]] && output error "Missing 2nd argument" && ((INPUT_ERRORS++))
	[[ -z "${3}" ]] && output error "Missing 3rd argument" && ((INPUT_ERRORS++))

	local USAGE_STRING="rgb2hex <R value> <G value> <B value>"
	[[ "${INPUT_ERRORS}" != "0" ]] && echo && output usage "${USAGE_STRING}" && return

	# Convert to hex values
	local HEX_VAL_1 HEX_VAL_2 HEX_VAL_3
	HEX_VAL_1=$(dechex "${1}" -s)
	HEX_VAL_2=$(dechex "${2}" -s)
	HEX_VAL_3=$(dechex "${3}" -s)
	local HEX_STRING="${HEX_VAL_1}${HEX_VAL_2}${HEX_VAL_3}"

	hex2color "#${HEX_STRING}"
}

#### Functions: Color ==final ####


#### Functions: Misc ==start ####

# Check if a binary is installed/present in ${PATH}, without stdout/stderr
# This is for bash, not for POSIX
hash() {
	builtin hash "${1+"$@"}" &> /dev/null
	return "${?}"
}

#### Functions: Misc ==final ####


#### Functions: Text ==start ####

# Output formatted text
# I would have used an associative array (and in one version, I did),
# but it's only in bash 4+ which is ... more rarely seen than I'd like
output() {
	# Array of options
	local ARRAY_USAGE_OPTIONS=(
	alert    backtick black  blue          cyan
	error    failure  gray   green         keyval
	keyval-f keyval-t leadup leadup-custom orange
	pink     purple   red    stderr        success
	usage    white    yellow
	)

	# Create variable of pipe-separated options from array
	local USAGE_STRING
	USAGE_STRING="output <$(IFS=$'|'; echo "${ARRAY_USAGE_OPTIONS[*]}")> <string 1> [<string 2, for keyval options>]"

	# Case statement for output color/format
	case "${1}" in
		# Basic colors
		alert)  local COLOR_SELECTED="${C_ALT}";;
		black)  local COLOR_SELECTED="${C_BLK}";;
		blue)   local COLOR_SELECTED="${C_BLU}";;
		cyan)   local COLOR_SELECTED="${C_CYN}";;
		gray)   local COLOR_SELECTED="${C_GRY}";;
		green)  local COLOR_SELECTED="${C_GRN}";;
		orange) local COLOR_SELECTED="${C_ORN}";;
		pink)   local COLOR_SELECTED="${C_PNK}";;
		purple) local COLOR_SELECTED="${C_PRP}";;
		red)    local COLOR_SELECTED="${C_RED}";;
		white)  local COLOR_SELECTED="${C_WHT}";;
		yellow) local COLOR_SELECTED="${C_YLW}";;

		backtick)
			# Output the input string with backticks (for Slack, mainly)
			local OUTPUT_FORMAT="${C_CODE}${C_BLD}\`%s\`${C_RST}\n"

			# Copy string to clipboard if not connected via SSH and binary is present
			[[ -z "${SSH_CONNECTION}" ]] && hash pbcopy && printf "\`%s\`" "${2}" | pbcopy
			;;

		error)
			# Special function to output to stderr
			local OUTPUT_STDERR="1>&2"
			local OUTPUT_FORMAT="${C_RED_BRT_BLD}Error ${C_WHT_BRT}: ${C_RST}%s\n"
			;;

		failure)
			# Special function for failure message, no string input
			local COLOR_SELECTED="${C_RED_BRT_BLD}"
			local OUTPUT_STRING="failure"
			;;

		keyval)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			local OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_YLW}%s${C_GRY}'${C_RST}\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		keyval-f)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			local OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_RED}%s${C_GRY}'${C_RST}\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		keyval-t)
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			local OUTPUT_FORMAT="${C_BLU}%s${C_WHT_BRT} : ${C_GRY}'${C_GRN}%s${C_GRY}'${C_RST}\n"

			# Output special format and immediately return
			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		leadup) # Special function for leadup to status message, no newline
			# Create dot string and output format
			printf -v LOADING_DOT_STRING '%*s' $((70-${#2}-${#3})) ''
			local OUTPUT_FORMAT
			OUTPUT_FORMAT="${C_RST}Performing ${C_GRY}'${C_ORN_BRT}%s${C_GRY}'${C_RST} ${C_WHT_BRT}$(printf '%s' "${LOADING_DOT_STRING// /.}") ${C_RST}"
			;;

		leadup-custom) # Special function for leadup to status message, no newline, with custom command name
			# Check for 2nd and 3rd args
			if [[ -z "${2}" || -z "${3}" ]]; then
				output usage "${USAGE_STRING}"
				return
			fi

			# Create dot string and output format
			printf -v LOADING_DOT_STRING '%*s' $((70-${#2}-${#3})) ''
			local OUTPUT_FORMAT
			OUTPUT_FORMAT="${C_RST}%s ${C_GRY}'${C_ORN_BRT}%s${C_GRY}'${C_RST} ${C_WHT_BRT}$(printf '%s' "${LOADING_DOT_STRING// /.}") ${C_RST}"

			printf "${OUTPUT_FORMAT}" "${2}" "${3}"
			return
			;;

		stderr)
			# Special function to output to stderr
			local COLOR_SELECTED="${C_BLU}"
			local OUTPUT_STDERR="1>&2"
			;;

		success)
			# Special function for success message, no string
			local COLOR_SELECTED="${C_GRN_BRT_BLD}"
			local OUTPUT_STRING="success"
			;;

		usage)
			# Special function to output formatted usage string, with stderr output
			local OUTPUT_FORMAT="${C_YLW_BRT_BLD}Usage ${C_WHT_BRT}: ${C_RST}%s\n"
			local OUTPUT_STDERR="1>&2"
			;;

		*) local COLOR_SELECTED="${C_RST}";; # If nothing matches, reset color
	esac

	# Check for variables and throw usage message if issue
	if [[ -z "${OUTPUT_STRING-${2}}" ]]; then
		output usage "${USAGE_STRING}"
		return
	fi

	# Finalize vars
	local OUTPUT_FORMAT="${OUTPUT_FORMAT-${COLOR_SELECTED}%s${C_RST}\n}"
	local OUTPUT_STRING="${OUTPUT_STRING-${2}}"

	# Output to stdout or stderr based on switch
	[[ "${OUTPUT_STDERR}" ]] && printf "${OUTPUT_FORMAT}" "${OUTPUT_STRING}" 1>&2 && return
	printf "${OUTPUT_FORMAT}" "${OUTPUT_STRING}"
}

#### Functions: Text ==final ####


#### Functions: Ping ==start ####

# Custom fping commands
kping() {
	local USAGE_STRING="kping <target IP/host> [<optional interval in milliseconds>]"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	# Default interval is 500ms
	local PING_INTERVAL="500"
	# Unless otherwise specified
	[[ "${2}" ]] && local PING_INTERVAL="${2}"

	fping -AdDelsu -H 254 -p "${PING_INTERVAL}" -t 1000 "${1}"
}

#### Functions: Ping ==final ####


#### Functions: Time ==start ####

# Elapsed time function
# Outputs in chrono format - '01:23:44'
# Arg1: start time in seconds
# Arg1: end time in seconds
_time_elapsed_chrono() {
	local CLK CLK_UNIT_COUNT CLK_UNIT_OUT OUTPUT_STRING TIME_END TIME_START TOT USAGE_OPTIONS_STRING

	# Array of options
	ARRAY_USAGE_OPTIONS=(current end)

	# Create variable of pipe-separated options from array
	USAGE_OPTIONS_STRING="$(IFS=$'|'; echo "${ARRAY_USAGE_OPTIONS[*]}")"

	if [[ -z "${1}" || -z "${2}" ]]; then
		output usage "time-elapsed-chrono <start> <${USAGE_OPTIONS_STRING}>"
		output usage "If using 'current' as end time, start time must be in sec sinch epoch (date +%s)"
	else
		# Case statement to setup current time as end time if specified
		case "${2}" in
			current)
				# Get current time (sec since epoch)
				TIME_END="$(date +%s)"
				;;
			*)
				TIME_END="${2}"
				;;
		esac

		# Variable setup
		# Get start time from argument, then compare the two variables to get elapsed time
		# Math commands below are scale=0 because we only want integers
		TIME_START="${1}"

		# Math for TOTAL timer
		TOT[0]=$((TIME_END-TIME_START))
		TOT[1]=$(echo "scale=0; ${TOT[0]}/60"       | bc)
		TOT[2]=$(echo "scale=0; ${TOT[0]}/3600"     | bc)
		TOT[3]=$(echo "scale=0; ${TOT[0]}/86400"    | bc)
		TOT[4]=$(echo "scale=0; ${TOT[0]}/604800"   | bc)
		TOT[5]=$(echo "scale=0; ${TOT[0]}/2419200"  | bc)
		TOT[6]=$(echo "scale=0; ${TOT[0]}/29030400" | bc)

		# Math for clock timer
		# This outputs an actual working counter/clock/stopwatch type display i.e 12:34:33
		# This works because of PEMDAS (order of operations)
		CLK[0]=$(echo "scale=0; ${TOT[0]}-${TOT[1]}*60" | bc)
		CLK[1]=$(echo "scale=0; ${TOT[1]}-${TOT[2]}*60" | bc)
		CLK[2]=$(echo "scale=0; ${TOT[2]}-${TOT[3]}*24" | bc)
		CLK[3]=$(echo "scale=0; ${TOT[3]}-${TOT[4]}*7"  | bc)
		CLK[4]=$(echo "scale=0; ${TOT[4]}-${TOT[5]}*4"  | bc)
		CLK[5]=$(echo "scale=0; ${TOT[5]}-${TOT[6]}*12" | bc)
		CLK[6]="${TOT[6]}"

		# Find how many units
		CLK_UNIT_COUNT="6"
		CLK_UNIT_OUT="6"

		# This basically finds the first non-zero digit in the array,
		# Starting from the top and working backwards
		while [[ "${CLK_UNIT_COUNT}" -gt "0" ]]; do
			[[ "${CLK[$CLK_UNIT_COUNT]}" != "0" ]] && break

			CLK_UNIT_OUT=$((CLK_UNIT_OUT-1))
			CLK_UNIT_COUNT=$((CLK_UNIT_COUNT-1))
		done

		while [[ "${CLK_UNIT_OUT}" -ge "0" ]]; do
			if [[ "${OUTPUT_STRING}" ]]; then
				OUTPUT_STRING="${OUTPUT_STRING}:$(printf %02d "${CLK[$CLK_UNIT_OUT]}")"
			else
				OUTPUT_STRING="$(printf %02d "${CLK[$CLK_UNIT_OUT]}")"
			fi

			CLK_UNIT_OUT=$((CLK_UNIT_OUT-1))
		done

		# If the total is less than 60 seconds, Append 00: and just output seconds
		[[ "${TOT[0]}" -lt "60" ]] && OUTPUT_STRING="00:${OUTPUT_STRING}"
		echo "${OUTPUT_STRING}"
	fi
}

# Elapsed time function
# Outputs in text format - '01 hours, 23 minutes, 44 seconds'
# Arg1: start time in seconds
# Arg1: end time in seconds
_time_elapsed_text() {
	# Declare vars as local
	local ARRAY_UNIT ARRAY_USAGE_OPTIONS CLK CLK_UNIT_COUNT CLK_UNIT_OUT OUTPUT_STRING TIME_END TIME_START TIME_UNIT_CURRENT TOT USAGE_OPTIONS_STRING

	# Array of options
	ARRAY_USAGE_OPTIONS=(current end)

	# Create variable of pipe-separated options from array
	USAGE_OPTIONS_STRING="$(IFS=$'|'; echo "${ARRAY_USAGE_OPTIONS[*]}")"

	if [[ -z "${1}" || -z "${2}" ]]; then
		output usage "time-elapsed-text <start> <${USAGE_OPTIONS_STRING}>"
		output usage "If using 'current' as end time, start time must be in 'seconds since epoch' (date +%s)"
	else
		# Case statement to setup current time as end time if specified
		case "${2}" in
			current)
				# Get current time (sec since epoch)
				TIME_END="$(date +%s)"
				;;
			*)
				TIME_END="${2}"
				;;
		esac

		# Variable setup
		# Get start time from argument, then compare the two variables to get elapsed time
		# Math commands below are scale=0 because we only want integers
		TIME_START="${1}"

		# Math for TOTAL timer
		TOT[0]=$((TIME_END-TIME_START))
		TOT[1]=$(echo "scale=0; ${TOT[0]}/60"       | bc)
		TOT[2]=$(echo "scale=0; ${TOT[0]}/3600"     | bc)
		TOT[3]=$(echo "scale=0; ${TOT[0]}/86400"    | bc)
		TOT[4]=$(echo "scale=0; ${TOT[0]}/604800"   | bc)
		TOT[5]=$(echo "scale=0; ${TOT[0]}/2419200"  | bc)
		TOT[6]=$(echo "scale=0; ${TOT[0]}/29030400" | bc)

		# Math for clock timer
		# This outputs an actual working COUNTER/clock/stopwatch type display i.e 12:34:33
		# This works because of PEMDAS (order of operations)
		CLK[0]=$(echo "scale=0; ${TOT[0]}-${TOT[1]}*60" | bc)
		CLK[1]=$(echo "scale=0; ${TOT[1]}-${TOT[2]}*60" | bc)
		CLK[2]=$(echo "scale=0; ${TOT[2]}-${TOT[3]}*24" | bc)
		CLK[3]=$(echo "scale=0; ${TOT[3]}-${TOT[4]}*7"  | bc)
		CLK[4]=$(echo "scale=0; ${TOT[4]}-${TOT[5]}*4"  | bc)
		CLK[5]=$(echo "scale=0; ${TOT[5]}-${TOT[6]}*12" | bc)
		CLK[6]="${TOT[6]}"

		# Find how many units
		CLK_UNIT_COUNT="6"
		CLK_UNIT_OUT="6"
		# This basically finds the first non-zero digit in the array,

		# Starting from the top and working backwards
		while [[ "${CLK_UNIT_COUNT}" -gt "0" ]]; do
			[[ "${CLK[$CLK_UNIT_COUNT]}" != "0" ]] && break
			CLK_UNIT_OUT=$((CLK_UNIT_OUT-1))
			CLK_UNIT_COUNT=$((CLK_UNIT_COUNT-1))
		done

		ARRAY_UNIT=(second minute hour day week month year)

		while [[ "${CLK_UNIT_OUT}" -ge "0" ]]; do
			TIME_UNIT_CURRENT="${ARRAY_UNIT[$CLK_UNIT_OUT]}"

			# Find if unit is plural or singular
			# i.e. not 1 of whatever time unit
			# Add the 's' at the end (plural)
			[[ "${CLK[$CLK_UNIT_OUT]}" != "1" ]] && TIME_UNIT_CURRENT="${TIME_UNIT_CURRENT}s"

			# Append the value and unit to the string
			if [[ "${OUTPUT_STRING}" ]]; then
				OUTPUT_STRING="${OUTPUT_STRING}, ${CLK[$CLK_UNIT_OUT]} ${TIME_UNIT_CURRENT}"
			else
				OUTPUT_STRING="${CLK[$CLK_UNIT_OUT]} ${TIME_UNIT_CURRENT}"
			fi

			# Find out if it's the last one in the array
			# If not, add a comma to the end
			[[ "${CLK_UNIT_OUT}" != "0" ]] && TIME_UNIT_CURRENT="${TIME_UNIT_CURRENT}, "

			# Decrement counter
			CLK_UNIT_OUT=$((CLK_UNIT_OUT-1))
		done
		echo "${OUTPUT_STRING}"
	fi
}

#### Functions: Time ==final ####


#### Functions: Array ==start ####

# Function to remove duplicates from array
_array_dedupe() {
	if [[ -z "${1}" ]]; then
		output usage "array-dedupe array[@]"
		output red   "NOTICE how there are NO curly brackets or quotes when you pass the variable"
		output red   "Don't say I didn't warn you"
		return
	fi

	# Magic BASH function array argument workaround
	declare -a ARRAY=("${!1}")

	# Convert array to string, swap spaces with newlines, unique sort
	echo "${ARRAY[@]}" | sed 's/\ /\n/g' | sort -u
}

# Function to get the length of the longest string in an array
_array_width() {
	if [[ -z "${1}" ]]; then
		output usage "array-width array[@]"
		output red   "NOTICE how there are NO curly brackets or quotes when you pass the variable"
		output red   "Don't say I didn't warn you"
		return
	fi

	# Magic BASH function array argument workaround
	declare -a ARRAY=("${!1}")

	# Init counter
	local WIDTH_MAX="0"

	# Loop through array
	for VALUE in "${ARRAY[@]}"; do
		[[ "${#VALUE}" -le "${WIDTH_MAX}" ]] && continue
		local WIDTH_MAX="${#VALUE}"
	done

	# Output value plaintext if in subshell
	if [[ "${BASH_SUBSHELL}" != "0" ]]; then
		echo "${WIDTH_MAX}"
		return
	fi

	# Colorized/formatted output if not in subshell
	output keyval "Array width" "${WIDTH_MAX}"
}

#### Functions: Array ==final ####


#### Functions: Conversion ==start ####

# Convert squid timestamps to human date and time
_convert_squid_timestamp() {
	local USAGE_STRING="convert-squid-timestamp <squid log timestamp>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	echo "${1}" | perl -p -e 's/^([0-9]*)/"[".localtime($1)."]"/e'
}

# Convert temperatures to other formats
_convert_temperature() {
	# Declare vars as local
	local SCALE TEMP_C TEMP_F TEMP_K TEMP_R PF_FMT USAGE_STRING

	USAGE_STRING="temp-conv <temperature[c|f|k|r]>"
	[[ "${1}" != *[0-9][CcFfKkRr]* ]] && output usage "${USAGE_STRING}" && return

	# Set calculation scale
	SCALE="2"

	# Detect input format (the ghetto way) and convert to Kelvin
	if [[ "${1}" == *[Cc]* ]]; then
		TEMP_C=${1//[!0-9]/}
		TEMP_K=$(echo "scale=${SCALE}; ${TEMP_C}+273.15" | bc)
	elif [[ "${1}" == *[Ff]* ]]; then
		TEMP_F=${1//[!0-9]/}
		TEMP_K=$(echo "scale=${SCALE}; ((${TEMP_F}-32)*(5/9))+273.15" | bc)
	elif [[ "${1}" == *[Kk]* ]]; then
		TEMP_K=${1//[!0-9]/}
	elif [[ "${1}" == *[Rr]* ]]; then
		TEMP_R=${1//[!0-9]/}
		TEMP_K=$(echo "scale=${SCALE}; ${TEMP_R}*(5/9)" | bc)
	fi

	# Calculate missing values (yes, I shave off a single CPU cycle not computing, only to spend it evaluating)
	[[ -z "${TEMP_C}" ]] && TEMP_C=$(echo "scale=${SCALE}; ${TEMP_K}-273.15"           | bc)
	[[ -z "${TEMP_F}" ]] && TEMP_F=$(echo "scale=${SCALE}; ((${TEMP_K}-273)*(9/5))+32" | bc)
	[[ -z "${TEMP_R}" ]] && TEMP_R=$(echo "scale=${SCALE}; ${TEMP_K}*(9/5)"            | bc)

	# Set margin for printf commands
	PF_FMT="%-8s${C_PRP}%s${C_RST}\n"

	# Output temperatures in various formats! yay!
	printf "${PF_FMT}" "${TEMP_C}" "C"
	printf "${PF_FMT}" "${TEMP_F}" "F"
	printf "${PF_FMT}" "${TEMP_K}" "K"
	printf "${PF_FMT}" "${TEMP_R}" "R"
}

# Convert hexadecimal<->decimal
dechex() {
	# Declare vars as local
	local DEC HEX INPUT OUTPUT PROCESS USAGE_STRING

	USAGE_STRING="dec2hex <decimal number> [-s, script output]"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	# Strip input of anything other than a-f, A-F, x, X, or numbers
	INPUT="${1//[^a-fA-FxX0-9]/}"
	# Uppercase input (except x)
	INPUT=$(echo "${INPUT}" | tr '[:lower:]' '[:upper:]' | sed 's/^0X/0x/g')

	# Detect input type
	if [[ "${INPUT}" =~ ^0x[A-F0-9]? ]]; then
		# Input is hexadecimal
		PROCESS="hex2dec"
		[[ "${#INPUT}" == "2" ]] && output error "Invalid input" && return 1 # Bounce if invalid input
		DEC="$((INPUT))" # Render decimal value
	else
		# Input is decimal
		PROCESS="dec2hex"
		DEC="${INPUT}"
	fi

	# Render formatted hex value
	HEX="$(printf '0x%02X' "${INPUT}")"

	# Format decimal value if value is not "0"
	if [[ "${DEC}" != "0" ]]; then
		DEC="${DEC##+(0)}"    # Remove leading zeros
		DEC="${DEC//[^0-9]/}" # Remove non-numbers
		[[ "${#DEC}" == "0" ]] && output error "Invalid input" && return 1 # Bounce if invalid input
	fi

	if [[ "${2}" != "-s" ]]; then
		output purple "Process : ${PROCESS}"
		output green  "Values  : ${DEC} | ${HEX}"
	else
		case "${PROCESS}" in
			dec2hex)
				OUTPUT="${HEX/0x/}"
				;;
			hex2dec)
				OUTPUT="${DEC}"
				;;
		esac

		echo "${OUTPUT}"
	fi
}

# Command aliases for above function
alias hexdec='dechex'

#### Functions: Conversion ==final ####


#### Functions: Android ==start ####

# Make md5sum file for a Android recovery
_android_make_md5() {
	# Declare vars as local
	local FILE_MD5 FILE_NAME USAGE_STRING

	! hash md5sum && output error "md5sum not available" && return
	USAGE_STRING="android-make-md5 <filename>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	FILE_NAME="${1}"
	FILE_MD5="$(md5sum "${FILE_NAME}" | awk '{print $1}')"
	echo ''"${FILE_MD5}"' *'"${FILE_NAME}"'' > "${FILE_NAME}.md5sum"

	output purple "md5sum created"
	output yellow "Filename  : ${FILE_NAME}.md5sum"
	output green  "Signature : ${FILE_MD5}"
}

#### Functions: Android ==final ####


#### Functions: SSH ==start ####

# Ping it, then ssh to it
# shellcheck disable=SC2029
_ssh_ping() {
	local USAGE_STRING="ssh-ping <host>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	ping "${1}"
	ssh  "${1}" "${2}"
}

# Show full path for SCPing
_show_scp_path() {
	# Declare vars as local
	local FILE_NAME FILE_TYPE SCP_CMD SCP_PATH SELECTED

	# If no argument, select current directory
	SELECTED="${PWD}"
	[[ "${1}" ]] && SELECTED="${1}"

	# Check if file exists
	[[ ! -e "${SELECTED}" ]] && output error "'./${1}' is not a valid file" && return

	# Get realpath of argument, and then swap out the home directory with a tilde
	SELECTED="$(realpath "${SELECTED}")"
	SCP_PATH="${SELECTED/$HOME/\~}"

	# Check if argument is a file or folder, fill variables accordingly
	if [[ -d "${SELECTED}" ]]; then
		FILE_NAME="${SCP_PATH}"
		FILE_TYPE="folder"
		SCP_CMD="scp -r"
	else
		FILE_NAME="$(basename "${SCP_PATH}")"
		FILE_TYPE="file"
		SCP_CMD="scp"
	fi

	echo
	output purple "Download ${FILE_NAME} from ${HOST_SHORT}:"

	printf "${SCP_CMD} ${C_ENV}${USER}@${HOST_SHORT}${C_RST}:${C_BLU}${SCP_PATH}${C_RST} .\n"
	printf "${SCP_CMD} ${C_ENV}${USER}@${HOSTNAME}${C_RST}:${C_BLU}${SCP_PATH}${C_RST} .\n"
	printf "${SCP_CMD} ${C_ENV}${USER}@${HOST_IP}${C_RST}:${C_BLU}${SCP_PATH}${C_RST} .\n"
	echo

	# Output upload instructions if FILE_TYPE is folder
	[[ ! -d "${SELECTED}" ]] && return

	output purple "Upload \${FILE} to ${HOST_SHORT}:${SCP_PATH}/ (fill in the blank variable)"

	printf "${C_CYN}FILE${C_RST}=${C_YLW}\"\"; ${C_RST}scp ${C_PRP}-r ${C_YLW}\"${C_PRP}\${FILE}${C_YLW}\"${C_RST} ${C_ENV}${USER}@${HOST_SHORT}${C_RST}:${C_BLU}${SCP_PATH}/${C_RST}\n"
	printf "${C_CYN}FILE${C_RST}=${C_YLW}\"\"; ${C_RST}scp ${C_PRP}-r ${C_YLW}\"${C_PRP}\${FILE}${C_YLW}\"${C_RST} ${C_ENV}${USER}@${HOSTNAME}${C_RST}:${C_BLU}${SCP_PATH}/${C_RST}\n"
	printf "${C_CYN}FILE${C_RST}=${C_YLW}\"\"; ${C_RST}scp ${C_PRP}-r ${C_YLW}\"${C_PRP}\${FILE}${C_YLW}\"${C_RST} ${C_ENV}${USER}@${HOST_IP}${C_RST}:${C_BLU}${SCP_PATH}/${C_RST}\n"
	echo
}

# With compression
# shellcheck disable=SC2029
_ssh_c() {
	local USAGE_STRING="ssh-c <host>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	ssh -o Compression=yes "${1}"
}

# With X forwarding
# shellcheck disable=SC2029
_ssh_x() {
	local USAGE_STRING="ssh-x <host>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	ssh -o ForwardX11=yes -o ForwardX11Trusted=yes "${1}"
}

# With compressed X forwarding
# shellcheck disable=SC2029
_ssh_xc() {
	local USAGE_STRING="ssh-xc <host>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	ssh -o Compression=yes -o ForwardX11=yes -o ForwardX11Trusted=yes "${1}"
}

#### Functions: SSH ==final ####


#### Functions: Git ==start ####

# Show Git-related info
_g_gi() {
	# Declare vars as local
	local BRANCH COMMIT CONFIG DIR HASH RELEASE TAG TAGS TOP URL

	BRANCH="$(git symbolic-ref --short HEAD 2> /dev/null)"
	COMMIT="$(git rev-parse HEAD            2> /dev/null)"
	DIR="$(   git rev-parse --git-dir       2> /dev/null)"
	TOP="$(   git rev-parse --show-toplevel 2> /dev/null)"
	URL="$(   git config remote.origin.url  2> /dev/null)"

	[[ -z "${BRANCH}" ]] && output error "No branch detected" && return
	[[ -z "${COMMIT}" ]] && output error "No commit detected" && return
	[[ -z "${DIR}"    ]] && output error "No repo detected"   && return
	[[ -z "${TOP}"    ]] && output error "No toplvl detected" && return
	[[ -z "${URL}"    ]] && output error "No URL detected"    && return

	CONFIG="${TOP}/${DIR}/config"
	[[ ! -s "${CONFIG}" ]] && output error "No config data detected" && return

	output orange "---------------------= git info =---------------------"
	output keyval "    URL" "${URL}"
	output keyval " Branch" "${BRANCH}"
	output keyval "Top lvl" "${TOP/$HOME/\~}"
	output keyval " Config" "${CONFIG/$HOME/\~}"
	output keyval " Commit" "${COMMIT}"

	# Git tag-related data
	TAGS="$(git describe --tags 2> /dev/null)"

	if [[ "${TAGS}" ]]; then
		HASH=$(    echo "${TAGS##v}" | awk -F '-' '{print $3}')
		TAG=$(     echo "${TAGS##v}" | awk -F '-' '{print $1}')
		RELEASE="$(echo "${TAGS##v}" | awk -F '-' '{print $2}').git${HASH##g}"

		[[ "${TAGS}" ]] && output keyval "   Tags" "${TAGS}"
		[[ "${HASH}" ]] && output keyval "   Hash" "${HASH}"
		[[ "${TAG}"  ]] && output keyval "Version" "${TAG}"

		if [[ "${RELEASE}" && "${RELEASE}" != ".git" ]]; then
			output keyval "Release" "${RELEASE}"
		fi
	fi
	echo

	_g_gs
}

# Git command wrapper for formatted output
_g_wrapper() {
	# Declare vars as local
	local CMD_EXIT GIT_CMD TEMP_FILE

	[[ -z "${1}" ]] && output error "No command provided to _g_wrapper" && return 254
	GIT_CMD="${1}"

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git -c "color.${GIT_CMD}=always" "${GIT_CMD}" > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] ----------------= git ${GIT_CMD} =--------------------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null
	return ${CMD_EXIT}
}

# Git status
_g_gs() {
	_g_wrapper status
}

# Git fetch, git pull, git update-all-the-submodules-to-latest
_g_gsu() {
	# Declare vars as local
	local CMD_EXIT GIT_BRANCH TEMP_FILE

	GIT_BRANCH="$(git symbolic-ref --short HEAD)"
	[[ -z "${GIT_BRANCH}" ]] && output error "No branch detected" && return

	_g_wrapper fetch
	CMD_EXIT="${?}"
	[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}

	# Check if there is an update
	if [[ "$(git log "HEAD..origin/${GIT_BRANCH}" --oneline 2>&1)" ]]; then
		# Perform git pull
		_g_wrapper pull
		CMD_EXIT="${?}"
		[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}
	else
		output blue "No git update available"
		echo
	fi

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git -c color.submodule=always submodule foreach --recursive 'git checkout master; git fetch; git pull' > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] ----------= git submodule update =-------------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null
	[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}

	_g_gs
	CMD_EXIT="${?}"
	return ${CMD_EXIT}
}

# Git fetch, git pull
_g_gu() {
	# Declare vars as local
	local CMD_EXIT GIT_BRANCH TEMP_FILE

	GIT_BRANCH="$(git symbolic-ref --short HEAD)"
	[[ -z "${GIT_BRANCH}" ]] && output error "No branch detected" && return

	_g_wrapper fetch
	CMD_EXIT="${?}"
	[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}

	# Check if there is an update
	if [[ "$(git log "HEAD..origin/${GIT_BRANCH}" --oneline 2>&1)" ]]; then
		# Perform git pull
		_g_wrapper pull
		CMD_EXIT="${?}"
		[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}
	else
		output blue "No git update available"
		echo
	fi

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git -c color.submodule=always submodule update --init > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] ----------= git submodule update --init =-------------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null
	[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}

	_g_gs
	CMD_EXIT="${?}"
	return ${CMD_EXIT}
}

# Git commit all w/message
_g_gca() {
	# Declare vars as local
	local COMMIT_MSG CMD_EXIT GIT_BRANCH TEMP_FILE USAGE_STRING

	USAGE_STRING="g-gca <commit message>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return
	COMMIT_MSG="${1}"

	output keyval "Committing changes, with message" "${COMMIT_MSG}"
	echo

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git -c color.commit=always commit -a -m "${COMMIT_MSG}" > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] -------= git commit -a -m '${COMMIT_MSG}' =-----------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null

	if [[ "${CMD_EXIT}" == "0" ]]; then
		_g_gs
		CMD_EXIT="${?}"
	fi

	return ${CMD_EXIT}
}

# Git push origin
_g_gpo() {
	# Declare vars as local
	local ARRAY_BRANCHES ARRAY_USAGE_OPTIONS BRANCHES_STRING CMD_EXIT SELECTED_BRANCH TEMP_FILE USAGE_OPTIONS_STRING

	# Create variable of pipe-separated options from array
	ARRAY_USAGE_OPTIONS=(c d t m p pp)
	USAGE_OPTIONS_STRING="$(IFS=$'|'; echo "${ARRAY_USAGE_OPTIONS[*]}")"

	# Array of branches
	ARRAY_BRANCHES=(
	current
	develop
	testing
	master
	production
	postprod
	)

	# Create variable of pipe-separated branches from array
	BRANCHES_STRING="$(IFS=$'|'; echo "${ARRAY_BRANCHES[*]}")"

	case "${1}" in
		c)
			SELECTED_BRANCH="$(git symbolic-ref --short HEAD 2> /dev/null)"
			[[ -z "${SELECTED_BRANCH}" ]] && output error "No branch detected" && return
			;;

		d) SELECTED_BRANCH="develop" ;;
		t) SELECTED_BRANCH="testing" ;;
		m) SELECTED_BRANCH="master" ;;
		p) SELECTED_BRANCH="production" ;;
		p) SELECTED_BRANCH="postprod" ;;
		*) output usage "g-gpo <${USAGE_OPTIONS_STRING}> <${BRANCHES_STRING}> <y>" && return ;;
	esac

	output keyval "Pushing to branch" "${SELECTED_BRANCH}"
	echo

	if [[ "${2##\-}" != [Yy] ]]; then
		read -r -p "Continue? [Y/n] " GIT_PUSH_YN
		echo

		[[ "${GIT_PUSH_YN}" == [Nn] ]] && output red "Push cancelled" && return 254
	fi

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git push --verbose origin "${SELECTED_BRANCH}" > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] ------= git push origin ${SELECTED_BRANCH} =----------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null

	if [[ "${CMD_EXIT}" == "0" ]]; then
		_g_gs
		local CMD_EXIT="${?}"
	fi

	return ${CMD_EXIT}
}

#### Functions: Git ==final ####


#### Functions: Net ==start ####

# Usage function for _net_curl
_net_curl_usage() {
	output usage "net-curl -u <URL> [-x <proxy>]"
}

# Check URL
_net_curl() {
	# Declare vars as local
	local CURL_EXIT CURL_PROXY CURL_PROXY_STRING OPTIND OPTS URL

	OPTS=":hu:x:"
	OPTIND h u x

	while getopts "${OPTS}" OPT; do
		case "${OPT}" in
			h)
				_net_curl_usage
				;;
			u)
				URL="${OPTARG}"
				;;
			x)
				CURL_PROXY="${OPTARG}"
				;;
			:)
				output usage "ERROR: Option -${OPTARG} requires an argument"
				echo
				_net_curl_usage
				;;
			\?)
				output usage "ERROR: Option -${OPTARG} is not a valid command line switch"
				echo
				_net_curl_usage
				;;
			*)
				_net_curl_usage
				break
				;;
		esac
	done

	shift $((OPTIND-1))

	[[ -z "${URL}" ]] && _net_curl_usage && return

	output usage "Using URL   : '${URL}'"

	if [[ -z "${CURL_PROXY}" ]]; then
		CURL_PROXY_STRING=''
	else
		output usage "Using proxy : 'http://${CURL_PROXY}:8080'"
		CURL_PROXY_STRING="-x http://${CURL_PROXY}:8080"
	fi
	echo

	curl -fLsvv "${CURL_PROXY_STRING}" -o /dev/null "${URL}" 2>&1
	CURL_EXIT="${?}"
	echo

	output usage "cURL exit code: ${CURL_EXIT}"
}

# Network config information
_net_info() {
	if hash hostname; then
		output keyval "hostname   " "$(hostname)"
		output keyval "hostname -s" "$(hostname -s)"
		[[ "${UNAME_KERNEL_NAME}" == "Linux" ]] && output keyval "hostname -d" "$(hostname -d)"
		output keyval "hostname -f" "$(hostname -f)"
		echo
	fi

	if hash ifconfig; then
		output purple "ifconfig:"
		ifconfig
		echo
	fi

	if hash netstat; then
		output purple "netstat -nr:"
		netstat -nr
		echo
	fi

	if [[ -s /etc/resolv.conf ]]; then
		output purple "resolv.conf:"
		cat /etc/resolv.conf
		echo
	fi

	if hash ip; then
		output purple "ip route show:"
		ip route show
		echo

		output purple "ip addr show ${DEFROUTE_NIC}:"
		ip addr show "${DEFROUTE_NIC}"
		echo
	fi
}

# Python webserver
_net_webserver() {
	# Declare vars as local
	local ARRAY_USAGE_OPTIONS USAGE_OPTIONS_STRING USAGE_STRING

	# Array of options
	ARRAY_USAGE_OPTIONS=(
	start
	stop
	)

	# Create variable of pipe-separated options from array
	USAGE_OPTIONS_STRING="$(IFS=$'|'; echo "${ARRAY_USAGE_OPTIONS[*]}")"

	USAGE_STRING="net-webserver <${USAGE_OPTIONS_STRING}>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	case "${1}" in
		start)
			if [[ "${WEBSERVER_RUNNING}" == "1" ]]; then
				output cyan "Webserver already running on port 8000"
				return
			fi

			# Start webserver
			{
				python -m SimpleHTTPServer &> /dev/null & disown
			}

			export WEBSERVER_PID="${!}"
			export WEBSERVER_RUNNING="1"
			output green "Webserver started on port 8000"
			;;
		stop)
			if [[ "${WEBSERVER_RUNNING}" != "1" ]]; then
				output yellow "Webserver not running"
				return
			fi

			kill -9 "${WEBSERVER_PID}"
			output red "Webserver stopped"
			;;
	esac
}

# Search a subnet for pinging IPs
_net_ping_subnet() {
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return
	local USAGE_STRING="net-ping-subnet <CIDR range>"

	# Return if fping is missing
	! hash fping && output error "fping not available" && return

	output purple "Pinging subnet '${1}'"
	# Sort by IP octets
	fping -a -i 10 -r 1 -p 20 -t 250 -g "${1}" 2> /dev/null | sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n
}

# Ping something 100 times and show a running average with printf
_net_ping_average() {
	# Declare vars as local
	local PF_FMT PING_AVERAGE PING_COLOR PING_COUNT PING_COUNT_FINAL PING_CURRENT PING_TOTAL USAGE_STRING

	USAGE_STRING="net-ping-average <target> [<optional count, default 100>]"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	# printf format used below
	PF_FMT="%-7s %s"

	# Print header
	printf "${C_PRP}${PF_FMT}${C_RST}\n" "Count" "Average (ms)"

	# Use the 2nd argument (ping total) if present, if not present, default of 100
	PING_COUNT_FINAL="${2-100}"

	# Init loop variables
	PING_COUNT="0"
	PING_TOTAL="0"
	PING_AVERAGE="0"
	PING_COLOR="${C_GRN}"

	# Print inital line so you have something to stare at before the first ping returns
	printf "${PING_COLOR}${PF_FMT}${C_RST}\r" "${PING_COUNT}" "${PING_AVERAGE}"

	# Loop until PING_COUNT reaches limit (PING_COUNT_FINAL)
	while [[ "${PING_COUNT}" -lt "${PING_COUNT_FINAL}" ]]; do
		# Ping host:
		# 1 ping
		# OS-specific ping timeout
		# pipe into awk to get ping time
		PING_CURRENT=$(ping -c 1 "${PING_WAIT}" "${1}" 2> /dev/null | awk -F '[ =]' '/from/ {printf $10; printf " "}' | sed 's/ //g')

		# If the ping inside of PING_CURRENT variable didn't return,
		# set PING_CURRENT to be the current average so as to not skew
		# the results
		#
		# Also, set output color to green if PING_CURRENT is populated,
		# else, set to red
		PING_COLOR="${C_GRN}"
		[[ -z "${PING_CURRENT}" ]] && PING_CURRENT="${PING_AVERAGE}" && PING_COLOR="${C_RED}"

		# Increment counter
		((PING_COUNT++))

		# Calculate total and average
		PING_TOTAL=$(  echo "scale=5; ${PING_TOTAL}+${PING_CURRENT}" | bc)
		PING_AVERAGE=$(echo "scale=5; ${PING_TOTAL}/${PING_COUNT}"   | bc)

		# Output string
		printf "${PING_COLOR}${PF_FMT}${C_RST}\r" "${PING_COUNT}" "${PING_AVERAGE}"
	done
	echo
}

# Ping something many times and output results in CSV for parsing
_net_ping_average_csv() {
	# Declare vars as local
	local PF_FMT PING_AVERAGE PING_COLOR PING_COUNT PING_COUNT_FINAL PING_CURRENT PING_TOTAL USAGE_STRING

	USAGE_STRING="net-ping-average-csv <target> [<optional count, default 100>]"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	# printf format used below
	PF_FMT="%-7s %s"

	# Print header
	printf "${C_PRP}${PF_FMT}${C_RST}\n" "Count" "Average (ms)" 1>&2

	# Use the 2nd argument (ping total) if present, if not present, default of 100
	PING_COUNT_FINAL="${2-100}"

	# Init loop variables
	PING_COUNT="0"
	PING_TOTAL="0"
	PING_AVERAGE="0"
	PING_COLOR="${C_YLW}"

	# Loop until PING_COUNT reaches limit (PING_COUNT_FINAL)
	while [[ "${PING_COUNT}" -lt "${PING_COUNT_FINAL}" ]]; do
		# Ping host:
		# 1 ping
		# OS-specific ping timeout
		# pipe into awk to get ping time
		PING_CURRENT=$(ping -c 1 "${PING_WAIT}" "${1} "2> /dev/null | awk -F '[ =]' '/from/ {printf $10; printf " "}' | sed 's/ //g')

		# If the ping inside of PING_CURRENT variable didn't return,
		# set PING_CURRENT to be the current average so as to not skew
		# the results
		#
		# Also, set output color to green if PING_CURRENT is populated
		[[ -z "${PING_CURRENT}" ]] && PING_CURRENT="${PING_AVERAGE}"

		# Increment counter
		PING_COUNT=$((PING_COUNT+1))

		# Calculate total and average
		PING_TOTAL=$(  echo "scale=5; ${PING_TOTAL}+${PING_CURRENT}" | bc)
		PING_AVERAGE=$(echo "scale=5; ${PING_TOTAL}/${PING_COUNT}"   | bc)

		# Output data string to stderr
		printf "${PING_COLOR}${PF_FMT}${C_RST}\r" "${PING_COUNT}" "${PING_AVERAGE}" 1>&2
	done
	echo -e "\n"             1>&2
	output purple "Results:" 1>&2

	# Output CSV string for passing to log
	echo "${PING_AVERAGE},${1}"
}

# Formats MAC address for all eventualities
_net_mac() {
	# Declare vars as local
	local CLEAN_MAC COLONS_LOWER COLONS_UPPER DASHES_LOWER DASHES_UPPER NONE_LOWER NONE_UPPER PF_FMT SPACES_LOWER SPACES_UPPER USAGE_STRING

	# Quit if nothing is entered
	USAGE_STRING="net-mac <MAC address, any format>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	# Strip MAC of anything other than 0-9, a-f, and A-F
	CLEAN_MAC="${1//[^a-fA-F0-9 ]/}"

	# Check the length of the cleaned MAC address. It should be 12 characters.
	[[ "${#CLEAN_MAC}" != "12" ]] && output error "'${1}' is invalid ('${CLEAN_MAC}' after sanitizing)" && return

	# If the MAC entered is kosher, build out the variables
	# Lowercase
	NONE_LOWER=$(  echo "${CLEAN_MAC}"  | tr '[:upper:]' '[:lower:]')
	COLONS_LOWER=$(echo "${NONE_LOWER}" | sed -e 's/\([0-9A-Fa-f]\{2\}\)/\1:/g' -e 's/\(.*\):$/\1/')
	DASHES_LOWER=$(echo "${NONE_LOWER}" | sed -e 's/\([0-9A-Fa-f]\{2\}\)/\1-/g' -e 's/\(.*\)-$/\1/')
	SPACES_LOWER=$(echo "${NONE_LOWER}" | sed -e 's/\([0-9A-Fa-f]\{2\}\)/\1 /g' -e 's/\(.*\) $/\1/')

	# Uppercase
	NONE_UPPER=$(  echo "${CLEAN_MAC}"  | tr '[:lower:]' '[:upper:]')
	COLONS_UPPER=$(echo "${NONE_UPPER}" | sed -e 's/\([0-9A-Fa-f]\{2\}\)/\1:/g' -e 's/\(.*\):$/\1/')
	DASHES_UPPER=$(echo "${NONE_UPPER}" | sed -e 's/\([0-9A-Fa-f]\{2\}\)/\1-/g' -e 's/\(.*\)-$/\1/')
	SPACES_UPPER=$(echo "${NONE_UPPER}" | sed -e 's/\([0-9A-Fa-f]\{2\}\)/\1 /g' -e 's/\(.*\) $/\1/')

	# Set margin for printf commands
	PF_FMT="${C_PRP}%-10s${C_RST}%-20s%s\n"

	# Output MAC address in various formats
	output purple "------------------------------ Formatted MAC --"
	printf "${PF_FMT}" "Colons" "${COLONS_LOWER}" "${COLONS_UPPER}"
	printf "${PF_FMT}" "Dashes" "${DASHES_LOWER}" "${DASHES_UPPER}"
	printf "${PF_FMT}" "Spaces" "${SPACES_LOWER}" "${SPACES_UPPER}"
	printf "${PF_FMT}" "None"   "${NONE_LOWER}"   "${NONE_UPPER}"

	# Perform IEEE MAC lookup
	echo
	_net_mac_lookup "${COLONS_LOWER}"
}

# Look up MAC address against IEEE database
_net_mac_lookup() {
	# Declare vars as local
	local IEEE_ADDRESS IEEE_COMPANY IEEE_COUNTRY IEEE_STRING PF_FMT USAGE_STRING

	# Check if oui npm package is installed
	! hash oui && output error "oui not available" && return

	USAGE_STRING="net-mac-lookup <MAC address with colons [at least first 3 octets]>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	IEEE_STRING="$(oui "${1}" | sed 's/,/ /g' | sed 's/  / /g' | sed ':a;N;$!ba;s/\n/,/g')"
	IEEE_COMPANY="$(echo "${IEEE_STRING}" | awk -F ',' '{print $1}')"
	IEEE_ADDRESS="$(echo "${IEEE_STRING}" | awk -F ',' '{print $2 ", " $3}')"
	IEEE_COUNTRY="$(echo "${IEEE_STRING}" | awk -F ',' '{print $4}')"

	PF_FMT="${C_PRP}%-10s${C_RST}%s\n"

	output purple "-------------------------------- IEEE lookup --"
	printf "${PF_FMT}" "Company" "${IEEE_COMPANY}"
	printf "${PF_FMT}" "Address" "${IEEE_ADDRESS}"
	printf "${PF_FMT}" "Country" "${IEEE_COUNTRY}"
}

# Lookup DNS information
_net_dns_lookup() {
	# Declare vars as local
	local HOST_CMD_INPUT HOST_CMD_IP LOOKUP_INPUT LOOKUP_IP LOOKUP_REVERSE LOOKUP_SERVER PF_FMT PF_FMT_REV USAGE_STRING

	USAGE_STRING="net-dns-lookup <hostname/IP> <optional DNS server>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	LOOKUP_INPUT="${1}"
	LOOKUP_SERVER="${2}"

	# Set up command string to include server if passed
	HOST_CMD_INPUT="host ${LOOKUP_INPUT} ${LOOKUP_SERVER}"

	# If alpha hostname, do lookup of hostname to get
	LOOKUP_IP="${LOOKUP_INPUT}"
	[[ "${LOOKUP_INPUT}" == *[aA-zZ]* ]] &&  LOOKUP_IP="$(${HOST_CMD_INPUT} | awk -F 'has address ' '/has address / {print $2}')"

	[[ -z "${LOOKUP_IP}" ]] && output yellow "Lookup of ${LOOKUP_INPUT} failed" && return

	output purple "--------------------------------- DNS lookup --"
	HOST_CMD_IP="host ${LOOKUP_IP} ${LOOKUP_SERVER}"
	LOOKUP_REVERSE=($(${HOST_CMD_IP} | awk -F 'domain name pointer ' '/domain name pointer / {print $2}' | sed 's/\.$//g'))

	# Set margin for printf commands
	PF_FMT="${C_PRP}%-10s${C_RST}%s\n"

	# Set color output to red if failed
	PF_FMT_REV="${PF_FMT}"
	[[ -z "${LOOKUP_REVERSE[0]}" ]] && LOOKUP_REVERSE[0]="Failed" && PF_FMT_REV="${C_PRP}%-10s${C_RED}%s${C_RST}\n"

	# Output returned data
	printf "${PF_FMT}" "Input" "${LOOKUP_INPUT}"
	[[ "${LOOKUP_SERVER}"  ]] && printf "${PF_FMT}" "Server" "${LOOKUP_SERVER}"

	if [[ "${LOOKUP_REVERSE[0]}" ]]; then
		# Loop through array of reverse DNS lookup entries
		for ENTRY in "${LOOKUP_REVERSE[@]}"; do
			printf "${PF_FMT_REV}" "Reverse" "${ENTRY}"
		done
	fi

	printf "${PF_FMT}" "Forward" "${LOOKUP_IP}"
}

#### Functions: Net ==final ####


#### Functions: Fix ==start ####

# Fix hung java processes
_fix_hung_java() {
	# Declare vars as local
	local JAVA_PIDS

	JAVA_PIDS=($(ps -ef | awk '/[j]ava/ {print $2}'))
	[[ -z "${JAVA_PIDS[0]}" ]] && output yellow "No Java PIDs detected" && return

	for JAVA_PID in "${JAVA_PIDS[@]}"; do
		if ! kill -9 "${JAVA_PID}" &> /dev/null; then
			output red "Failed to kill Java JAVA_PID ${JAVA_PID}"
		else
			output green "Killed Java JAVA_PID ${JAVA_PID}"
		fi
	done
}

# Stale bash threads fix
# shellcheck disable=SC2009
_fix_bash_pids() {
	# Declare vars as local
	local ARRAY_USAGE_OPTIONS FIX_BASH_PIDS_PID_COUNT FIX_BASH_PIDS_PID_LIST USAGE_OPTIONS_STRING

	# Array of options
	ARRAY_USAGE_OPTIONS=(
	show
	kill
	)

	# Create variable of pipe-separated options from array
	USAGE_OPTIONS_STRING="$(IFS=$'|'; echo "${ARRAY_USAGE_OPTIONS[*]}")"

	FIX_BASH_PIDS_PID_LIST=($(ps aux | grep -E '[b]ash' | grep -Ev 'root|s00\.' | sort -r | awk '{print $2}'))
	FIX_BASH_PIDS_PID_COUNT="${#FIX_BASH_PIDS_PID_LIST[@]}"

	output purple "Number of stale bash PIDs: ${FIX_BASH_PIDS_PID_COUNT}"

	if [[ ! "${FIX_BASH_PIDS_PID_COUNT}" == "0" ]]; then
		case "${1}" in
			show)
				output purple "PID list:"
				for PID in "${FIX_BASH_PIDS_PID_LIST[@]}"; do
					output yellow "${PID}"
				done
				;;
			kill)
				read -r -p "Kill stale bash PIDs? [Y/n] " FIX_BASH_PIDS_YN
				echo
				[[ "${FIX_BASH_PIDS_YN}" == [Nn] ]] && output purple "No PIDs killed" && return 1

				for PID in "${FIX_BASH_PIDS_PID_LIST[@]}"; do
					output yellow "Killing PID ${PID}"
					kill -9 "${PID}"
				done

				output green "Complete"

				# Check the PIDs again
				fix-bash-pids show
				;;
			*)
				output usage "fix-bash-pids <${USAGE_OPTIONS_STRING}>"
				;;
		esac
	fi
}

# Remove / clean macOS .DS_Store / attribute files
_fix_macos_files() {
	output purple "Finding all macOS metadata files under '${PWD}'"

	# Backup current IFS, change IFS to \n\b so as to parse file array
	local OLD_IFS="${IFS}"
	IFS=$(echo -en "\n\b")

	# File array of macOS-specific junk files
	local FILES_TO_REMOVE=($(find . -iname '*DS_Store' -o -iname '._*'))

	# Restore previous IFS
	IFS="${OLD_IFS}"

	[[ -z "${FILES_TO_REMOVE[0]}" ]] && output purple "No macOS attribute/Finder files under '${PWD}' to remove" && return

	output yellow "Removing these macOS attribute/Finder files under '${PWD}':"
	echo

	for FILE in "${FILES_TO_REMOVE[@]}"; do
		output yellow "${FILE}"
	done
	echo

	read -r -p "Are you sure you want to remove these files? [Y/n] " FIX_MACOS_FILES_YN
	echo
	[[ "${FIX_MACOS_FILES_YN}" == [Nn] ]] && output purple "No macOS attribute/Finder files under '${PWD}' removed" && return

	for FILE in "${FILES_TO_REMOVE[@]}"; do
		output yellow "Removing '${FILE}'"
		rm -f "${FILE}"
	done
	echo

	output green "All macOS attribute/Finder files under '${PWD}' removed"
}

#### Functions: Fix ==final ####


#### Functions: Find ==start ####

# Find dir function
# Case insensitive, double wildcard search of CURRENT dir
_find_dir() {
	local USAGE_STRING="find-dir <dirname>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	output stderr "Finding directory '${1}' under '${PWD}'"
	output stderr " "

	find . -type d -iname "*${1}*"
}

# Find file function
# Case insensitive, double wildcard search of CURRENT dir
_find_file() {
	local USAGE_STRING="find-file <filename>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

	output stderr "Finding file '${1}' under '${PWD}'"
	output stderr " "

	find . -type f -iname "*${1}*"
}

# Find ${COUNT} largest items in current directory
_find_largest() {
	local COUNT="${1-10}"
	output stderr "Searching for ${COUNT} largest items under '${PWD_FINAL}'"
	output stderr " "

	du -hs ./* | sort -hr | head -n "${COUNT}"
}

#### Functions: Find ==final ####


#### Functions: Show ==start ####

# Check if an executable exists, if so, show info about it
_show_bin() {
	# Declare vars as local
	local FILE_MIME FILE_PATH FILE_TYPE LS

	if ! hash "${1}"; then
		output error "Could not find '${1}' in defined PATH"
		return 1
	fi

	# Get full file path, type, and MIME encoding/type
	! FILE_PATH="$(which --skip-alias --skip-functions "${1}" 2> /dev/null)" && FILE_PATH="$(which "${1}" 2> /dev/null)"
	FILE_TYPE="$(file -bNn                             "${FILE_PATH}")"
	FILE_MIME="$(file -bNn --mime-encoding --mime-type "${FILE_PATH}")"

	# Detect GNU ls or stock macOS ls to enable color output properly
	if [[ "${MACOS_GNU}" || "${UNAME_KERNEL_NAME}" == "Linux" ]]; then
		LS='ls -hl --color=auto'
	else
		LS='ls -Ghl'
	fi

	"${LS}" "${FILE_PATH}" 2> /dev/null
	echo

	output green "Name : '${1}'"
	output blue  "Path : '${FILE_PATH}'"
	output blue  "Type : '${FILE_TYPE}'"
	output blue  "MIME : '${FILE_MIME}'"
}

# Show a clock
_show_clock() {
	# Declare vars as local
	local CMD_ECHO CMD_LOOP

	# Show a continuous clock if 1st arg is '-l'
	if [[ ${1} == "-l" ]]; then
		CMD_ECHO="echo -en"
		CMD_LOOP="sleep 0.9"
	else
		CMD_ECHO="echo -e"
		CMD_LOOP="break"
	fi

	while true; do
		"${CMD_ECHO}" "$(date '+%a %b %d %Y %r | %F %R:%S | %:z (%Z)')   \r"
		"${CMD_LOOP}"
	done
}

# Show most frequently executed commands
_show_top_cmds() {
	# Declare vars as local
	local BASH_HISTORY_CMDS COUNT

	[[ ! -s "${HISTFILE}" ]] && output error "bash history file missing or empty"
	BASH_HISTORY_CMDS="$(grep -cv '#' "${HISTFILE}")"
	COUNT="15"

	output stderr "-- ${BASH_HISTORY_CMDS} commands total -------------------- Top ${COUNT} --"
	grep -v '#' "${HISTFILE}" | sort | uniq -c | sort -rn | head -n "${COUNT}"
}

#### Functions: Show ==final ####


#### Functions: md5sum ==start ####

# Format the output of md5sum command
_md5_clean() {
	! hash md5sum && output error "md5sum not available" && return
	local USAGE_STRING="md5-clean <filename>, one file only"
	[[ -z "${1}" || "${2}" ]] && output usage "${USAGE_STRING}" && return
	md5sum "${1}" | awk '{print $1}'
}

# Do md5sum on two files and compare them
_md5_compare() {
	local USAGE_STRING="md5-compare <filename> <filename>, exit code only"
	[[ -z "${1}" || -z "${2}" ]] && output usage "${USAGE_STRING}" && return
	[[ $(_md5_clean "${1}") == $(_md5_clean "${2}") ]] && return 0 || return 1
}

#### Functions: md5sum ==final ####


#### Functions: PS1/bashrc ==start ####

# Generate / export PS1 prompt with color specfied by C_ENV
_prompt_generate() {
	# Return if we're not in a terminal
	[[ -t 2 ]] || return

	# If COLOR_16M is set to 0 in bash-env.conf, render PS1 without multicolor
	if grep -q 'COLOR_16M=0' "${BASH_ENV_FILE_CONFIG}"; then
		PS1="\[${C_ENV}\]\${HOST_SHORT}\[${C_RST}\]:\[${C_BLU}\]$(_prompt_pwd) \[${C_ENV}\]\\$\[${C_RST}\] "
		export PS1
		return
	fi

	# If NOT connected via SSH and PROMPT_NO_HOSTNAME is set to 1 (true) in bash-env.conf,
	# render PS1 without hostname
	if [[ -z "${SSH_CONNECTION}" ]]; then
		if grep -q 'PROMPT_NO_HOSTNAME=1' "${BASH_ENV_FILE_CONFIG}"; then
			PS1="\[${C_BLU}\]$(_prompt_pwd_color) \[${C_ENV}\]\\$\[${C_RST}\] "
			export PS1
			return
		fi
	fi

	# Normal PS1 prompt (with hostname)
	PS1="\[${C_ENV}\]\${HOST_SHORT}\[${C_RST}\]:\[${C_BLU}\]$(_prompt_pwd_color) \[${C_ENV}\]\\$\[${C_RST}\] "
	export PS1

	# Kick _prompt_pwd again with no output to export environment variables
	_prompt_pwd > /dev/null 2>&1

	# It would be neat to do a color-responsive system load monitor... but not today
}

# Print colorized exit code information
_prompt_exitcode() {
	# Return if we're not in a terminal
	[[ -t 2 ]] || return

	# Bounce if no arguments passed
	[[ -z "${1}" || -z "${2}" ]] && return

	# Bounce if exit code 0 or 127 (BASH command not found)
	case "${2}" in
		0)   return ;;
		127) return ;;
	esac

	local ARRAY_CMD=(${1})
	case "${ARRAY_CMD[0]}" in
		_prompt*) return ;;
		cd)       return ;;
		grep)     return ;;
		history)  return ;;

		.)      CMD="${ARRAY_CMD[0]} ${ARRAY_CMD[1]}" ;;
		source) CMD="${ARRAY_CMD[0]} ${ARRAY_CMD[1]}" ;;

		*) CMD="${ARRAY_CMD[0]}" ;;
	esac

	local STR="%s${C_RST}"

	local ENV="${C_ENV}${STR}"
	local GRY="${C_GRY}${STR}"
	local RED="${C_RED_BRT_BLD}${STR}"
	local WHT="${C_WHT_BRT}${STR}"
	local YLW="${C_YLW}${STR}"

	local ARRAY_CMD=(${1})
	printf "${GRY} ${RED} ${WHT} ${GRY}\n" "${CMD}" "failed" ":" "${2}"
}

# Print exit code right-aligned for the PS1 prompt
_prompt_right() {
	# Set color based on exit code
	local CLR;
	case "${1}" in
		0) CLR="${C_GRN}"	;;
		*) CLR="${C_ALT}" ;;
	esac

	# Trim off 2+length of 1st argument
	local TRIM="${#1}"; ((TRIM++))
	printf "${C_GRY}%*s${CLR}%s${C_RST}${C_GRY}%s${C_RST}\r" "$((COLUMNS-TRIM))" "[" "${1}" "]"
}

_prompt_pwd() {
	# Get the current directory, swap out the home directory with a tilde
	PWD_FMT=${PWD/${HOME}/\~}
	export PWD_FMT

	# Here we modify the pwd string to shorten the display
	# Find how many folders deep we are
	PWD_FMT_DEPTH="$(echo "${PWD_FMT}" | awk -F '/' '{print NF-1}')"
	export PWD_FMT_DEPTH

	# If we're LESS than 3 folders deep, pwd for titlebar and prompt is normal
	# If we're MORE than 3 folders deep, show ../previous_dir/current_dir
	PWD_CUSTOM=$(printf "${PWD_FMT}" | rev | awk -F '/' '{printf $1"/"$2"/.."}' | rev)
	export PWD_CUSTOM

	[[ "${PWD_FMT_DEPTH}" -lt "3" ]] && PWD_FINAL="${PWD_FMT}" || PWD_FINAL="${PWD_CUSTOM}"
	export PWD_FINAL

	echo "${PWD_FINAL}"
}

# Function to fire the below function due to wonky arg parsing
_prompt_pwd_color() {
	_prompt_pwd_color_render "$(_prompt_pwd)"
}

# Render color-separated formatted pwd
_prompt_pwd_color_render() {
	local OLDIFS IFS INPUT DIRS SEPARATORS DEPTH COUNT STR
	local RST CYN BLU YLW GRY PRP

	# Escape color sequences for PS1 compatiblity
	RST="\[${C_RST}\]"
	CYN="\[${C_CYN}\]"
	BLU="\[${C_BLU_BRT_BLD}\]"
	YLW="\[${C_YLW}\]"
	GRY="\[${C_GRY}\]"
	PRP="\[${C_PRP}\]"

	# Color configuration
	DIRS[0]="${CYN}"
	DIRS[1]="${BLU}"

	SEPARATORS[0]="${YLW}.."
	SEPARATORS[1]="${GRY}/"
	SEPARATORS[2]="${PRP}~"

	# Set separator to forward slash
	OLDIFS="${IFS}"
	IFS='/'

	# Render input PATH into array by temporarily disabling glob expansion
	# ($@) is deliberately unquoted
	set -f; INPUT=($@); set +f

	# Reset separator
	IFS="${OLDIFS}"

	# Init loop cariables
	DEPTH="${#INPUT[@]}"
	COUNT="0"
	STR=""

	# Special color coding for certain leading characters
	case "${INPUT[0]}" in
		'..') STR+="${SEPARATORS[0]}" ;;
		'~')  STR+="${SEPARATORS[2]}" ;;
	esac

	# Add a slash if we're in / directory
	[[ "${*}"      == "/" ]] && STR+="${SEPARATORS[1]}"
	# Add a slash if we're somewhere more than 1 dir deep
	[[ "${DEPTH}" -gt "1" ]] && STR+="${SEPARATORS[1]}"
	((COUNT++))

	# Add color to path elements
	INPUT[1]="${DIRS[0]}${INPUT[1]}"
	INPUT[2]="${DIRS[1]}${INPUT[2]}"

	# Concatenate color-formatted string
	while [[ "${COUNT}" != "${DEPTH}" ]]; do
		STR+="${INPUT[$COUNT]}"
		((COUNT++))

		# Append a trailing slash if proper to do so
		[[ "${COUNT}" != "${DEPTH}" ]] && STR+="${SEPARATORS[1]}"
	done

	STR+="${RST}"

	# Print the color-formatted string
	printf "%s" "${STR}"
}

_prompt_titlebar() {
	# Return if we're not in a terminal
	[[ -t 2 ]] || return

	# Add '[SSH]' to titlebar if in SSH session
	[[ "${SSH_CONNECTION}" ]] && local TITLEBAR_SSH="[SSH] "

	# Only apply custom titlebar if we're in xterm and on Bash 3+
	[[ "${TERM}" == *"xterm"* && "${BASH_VERSINFO[0]}" -ge "3" ]] && printf "\033]0;%s%s\007" "${TITLEBAR_SSH}" "${HOST_SUB}:$(_prompt_pwd)"
}

# Dynamic MOTD with facter (if present)
_show_motd() {
	# Declare vars as local
	local ARRAY_VALUES ARROW_L ARROW_R BAR BASE_KEY CPU DST FACTER_MEMORY FACTER_OS HASH HEAD_FMT HEAD_KEY HEAD_VAL1 HEAD_VAL2 LOAD MOTD_FMT MOTD_KEY MOTD_VAL1 MOTD_VAL2 OLD_PWD RAM RAMC STRING_LENGTH UPT VER

	# Return if we're not in a terminal
	[[ -t 2 ]] || return

	# Color shortcuts
	BAR="${C_BLK_BLD}|${C_RST}"
	ARROW_L="${C_BLK_BLD}<${C_RST}"
	ARROW_R="${C_BLK_BLD}>${C_RST}"

	BASE_KEY="%s${C_RST}"
	HEAD_KEY="${C_ENV}${BASE_KEY}"

	# kdm bash-env git hash
	HASH="#$(_kdm_hash)"

	# Check for jq binary
	if ! hash jq; then
		# Output warning message about jq being missing
		echo -e "jq not available; dynamic MOTD not possible\n"

		# Print just the env hash
		# Assemble header format string
		HEAD_VAL1="${C_BLU_BLD}%+s${C_RST}"
		HEAD_VAL2="${C_BLU_BLD}%-s${C_RST}"
		HEAD_FMT="${HEAD_KEY} ${ARROW_R} ${HEAD_VAL1} ${BAR} ${HEAD_VAL2} ${ARROW_L} ${HEAD_KEY}\n"
		printf "${HEAD_FMT}\n" "kdm" "bash-env" "${HASH}" "rev"
		return 1
	fi

	# Use facter if possible, if not, too bad..
	if ! hash facter; then
		# Check if we already said this
		if ! grep -q 'WARN_FACTER=1' "${BASH_ENV_FILE_CONFIG}"; then
			sed -i '/WARN_FACTER/d' "${BASH_ENV_FILE_CONFIG}"
			echo   'WARN_FACTER=1' >> "${BASH_ENV_FILE_CONFIG}"

			# Output warning message about facter being missing
			echo -e "facter not available; dynamic MOTD not possible\n"
		fi

		# Print just the env hash
		# Assemble header format string
		HEAD_VAL1="${C_BLU_BLD}%+s${C_RST}"
		HEAD_VAL2="${C_BLU_BLD}%-s${C_RST}"
		HEAD_FMT="${HEAD_KEY} ${ARROW_R} ${HEAD_VAL1} ${BAR} ${HEAD_VAL2} ${ARROW_L} ${HEAD_KEY}\n"
		printf "${HEAD_FMT}\n" "kdm" "bash-env" "${HASH}" "rev"
		return 1
	fi

	# Generate the OS info string differently, based on OS
	FACTER_OS="$(facter -j os)"
	case "$(echo "${FACTER_OS}" | jq -r .os.family)" in
		Archlinux)
			DST="$(echo "${FACTER_OS}" | jq -r .os.name)"
			VER="$(echo "${FACTER_OS}" | jq -r .os.release.major).$(echo "${FACTER_OS}" | jq -r .os.release.minor)"
			;;
		Darwin)
			DST="macOS"
			VER="$(echo "${FACTER_OS}" | jq -r .os.macosx.version.major)"
			;;
		Debian)
			DST="$(echo "${FACTER_OS}" | jq -r .distro.id)"
			VER="$(echo "${FACTER_OS}" | jq -r .release.major)"
			;;
		RedHat)
			DST="$(echo "${FACTER_OS}" | jq -r .name)"

			case "$(echo "${FACTER_OS}" | jq -r .distro.id)" in
				CentOS|RedHat*) VER="$(echo "${FACTER_OS}" | jq -r .release.major).$(echo "${FACTER_OS}" | jq -r .release.minor)" ;;
				Fedora)         VER="$(echo "${FACTER_OS}" | jq -r .release.major)"                                               ;;
				*)              VER="$(echo "${FACTER_OS}" | jq -r .release.full)"                                                ;;
			esac
	esac

	# Get CPU, RAM, uptime, sysload, perhaps do some formatting
	FACTER_MEMORY="$(facter -j memory)"
	RAM="$( echo "${FACTER_MEMORY}" | jq -r .memory.system.total)"
	RAMC="$(echo "${FACTER_MEMORY}" | jq -r .memory.system.capacity)"

	CPU="$( facter processors.models.0 | sed -r -e 's/(^\s?)|(\s?CPU)|(\s?@)|(\s?Processor)|(\(.?.?\))|(\s?[0-9]\.[0-9]{1,3}GHz\s?)|(\s[0-9]\s)|(Intel\(..?\)\sCore\(..?\)\s?)|Intel\sCore\s|\(|\)|Intel\(..?\)\s|Atom|Xeon|\sv[1-9]|\s//g' -e 's/(\s)+/\ /g')"
	UPT="$( facter uptime)"
	LOAD="$(facter load_averages.5m)"

	# Format a couple things
	UPT="${UPT:0:8}"
	UPT="${UPT/\ hou/}"
	UPT="${UPT/\ ho/}"
	LOAD="${LOAD:0:4}"
	RAMC="${RAMC%%.*}%"
	RAM="${RAM%%.*}G/${RAMC}"

	# Find longest string in array for dynamic width
	ARRAY_VALUES=(
	"bash-env"
	"${HASH}"
	"${CPU}"
	"${RAM}"
	"${DST}"
	"${VER}"
	"${UPT}"
	"${LOAD}"
	)

	# Find the length of the longest string among the values
	for STRING in "${ARRAY_VALUES[@]}"; do
		STRING_LENGTH=${#STRING}

		# If the current string is longer than MAX_LEN, set MAX_LEN to the current string's length
		[[ "${STRING_LENGTH}" -gt "${MAX_LEN}" ]] && MAX_LEN="${STRING_LENGTH}"

		# Quick dirty check if data exists
		if [[ -z "${STRING}" ]]; then
			echo -e "Failed evaluating data; dynamic MOTD not possible\n"
			return 2
		fi
	done

	# Example output:
	#
	# kdm > bash-env | #8af151d < v749
	# cpu >  i7-3770 | 16G      < ram
	#  os >    macOS | 10.11    < ver
	#  up >     1:04 | 1.28     < load

	# Set up printf format strings with C_ENV
	BASE_KEY="%s${C_RST}"
	BASE_VAL1="%+${MAX_LEN}s${C_RST}"
	BASE_VAL2="%-${MAX_LEN}s${C_RST}"

	MOTD_KEY="${C_BLU_BLD}${BASE_KEY}"
	MOTD_VAL1="${C_ENV}${BASE_VAL1}"
	MOTD_VAL2="${C_ENV}${BASE_VAL2}"

	HEAD_KEY="${C_ENV}${BASE_KEY}"
	HEAD_VAL1="${C_BLU_BLD}${BASE_VAL1}"
	HEAD_VAL2="${C_BLU_BLD}${BASE_VAL2}"

	# Assemble format strings
	HEAD_FMT="${HEAD_KEY} ${ARROW_R} ${HEAD_VAL1} ${BAR} ${HEAD_VAL2} ${ARROW_L} ${HEAD_KEY}${C_RST}\n"
	MOTD_FMT="${MOTD_KEY} ${ARROW_R} ${MOTD_VAL1} ${BAR} ${MOTD_VAL2} ${ARROW_L} ${MOTD_KEY}${C_RST}\n"

	# Output the header line, then the MOTD
	printf "${HEAD_FMT}" "kdm" "bash-env" "${HASH}" "rev"
	printf "${MOTD_FMT}" "cpu"   "${CPU}" "${RAM}"  "ram"
	printf "${MOTD_FMT}" " os"   "${DST}" "${VER}"  "ver"
	printf "${MOTD_FMT}" " up"   "${UPT}" "${LOAD}" "load"
	echo
}

#### Functions: PS1/bashrc ==final ####


#### Functions: kdm-bash-env ==start ####

# Re-source ${HOME}/.kdm/bashrc, then files in the 'source' dir
# shellcheck disable=SC1090
_kdm_source() {
	# Declare vars as local
	local OLD_PWD SOURCE_FILE SOURCE_PATH

	OLD_PWD="${PWD}"
	cd "${BASH_ENV_DIR_KDM}" || return

	export SOURCE_VERBOSE="true"

	for i in {0..22}; do
		SOURCE_FILE="$(printf '%02d' "${i}")-*)"
		SOURCE_PATH="$(ls "include/${SOURCE_FILE}")"
		[[ ! -s "${SOURCE_PATH}" ]] && continue
		if . "${SOURCE_PATH}"; then output keyval-t "Loaded" "${SOURCE_PATH}"; else output keyval-f "Failed" "${SOURCE_PATH}"; fi
	done

	unset SOURCE_VERBOSE

	cd "${OLD_PWD}" || return
	unset OLD_PWD
}

# Get Git hash of bash-env
_kdm_hash() {
	local OLD_PWD="${PWD}"
	cd "${HOME}" || return
	git log --pretty=format:'%h' -n 1
	cd "${OLD_PWD}" || return
}

# Help with/list bashrc functions
_kdm_help() {
	output purple "kdm bash-env functions:"
	echo

	local BASHRC_CMDS=($(grep -o 'alias\ .*.=' "${BASH_ENV_FILE_BASHRC}" | sort -u | awk -F '[ =]' '{print $2}' | sort -u | sed -r '/^.{,3}$/d' | grep -Ev 'pign|tial|namp|mkdir|grep|grpe|ehco|clean|CMD|^config|^log|^html\-|^xml\-|^json\-|lsusb|md5sum'))

	# macOS commands
	if [[ "${UNAME_KERNEL_NAME}" == "Darwin" ]]; then
		for CMD in "${BASHRC_CMDS[@]}"; do
			echo "${CMD}"
		done | grep -Ev '^sys\-restart|^kvm\-'
	fi

	# Linux commands
	if [[ "${UNAME_KERNEL_NAME}" == "Linux" ]]; then
		for CMD in "${BASHRC_CMDS[@]}"; do
			echo "${CMD}"
		done | grep -Ev '^osx\-|^net\-listening|efi\-mount'
	fi
	echo
}

# Quick-draw pull bash env
_kdm_pull() {
	# Declare vars as local
	local CMD_EXIT OLD_PWD

	# Save current PWD
	OLD_PWD="${PWD}"
	cd "${HOME}" || return

	_g_gu
	CMD_EXIT="${?}"

	cd "${OLD_PWD}" || return
	return ${CMD_EXIT}
}

#### Functions: kdm-bash-env ==final ####


#### Functions: Updates ==start ####

# Update all the things (except CPAN)
_update_all() {
	# Check 1st argument
	if [[ "${1}" != "-y" ]]; then
		# Check if they're sure
		read -r -p "Are you sure? [Y/n] " UPDATE_YN
		echo
		# Exit if they're not
		[[ "${UPDATE_YN}" == [Nn] ]] && output cyan "No updates performed" && return
	fi

	# Bounce if we couldn't find a supported package manager
	if [[ -z "${PACKAGE_MANAGER}" ]]; then
		output error "Could not detect package manager"
		return 1
	fi

	# Assemble array of command strings based on type of package manager
	unset ARRAY_COMMANDS
	case "${PACKAGE_MANAGER}" in
		"apt-get")
			local ARRAY_COMMANDS[0]="sudo ${PACKAGE_MANAGER} update"
			local ARRAY_COMMANDS[1]="sudo ${PACKAGE_MANAGER} -y upgrade"
			local ARRAY_COMMANDS[2]="sudo ${PACKAGE_MANAGER} -y dist-upgrade"
			;;
		"brew")
			local ARRAY_COMMANDS[0]="${PACKAGE_MANAGER} update"
			local ARRAY_COMMANDS[1]="${PACKAGE_MANAGER} upgrade"
			local ARRAY_COMMANDS[2]="${PACKAGE_MANAGER} cleanup"
			# macOS software update
			local ARRAY_COMMANDS[3]="sudo softwareupdate -i -a"
			;;
		"yum")
			local ARRAY_COMMANDS[0]="sudo ${PACKAGE_MANAGER} -y update"
			local ARRAY_COMMANDS[1]="sudo ${PACKAGE_MANAGER} -y upgrade"
			;;
		"pacman")
			local ARRAY_COMMANDS[0]="sudo ${PACKAGE_MANAGER} -Syu --quiet --noconfirm --noprogressbar"
			;;
		"zypper")
			local ARRAY_COMMANDS[0]="sudo ${PACKAGE_MANAGER} -n update"
			;;
		*)
			local ARRAY_COMMANDS[0]="sudo ${PACKAGE_MANAGER} -y update"
			;;
	esac

	# Perform update commands
	for COMMAND in "${ARRAY_COMMANDS[@]}"; do
		output leadup "${COMMAND}"
		if ${COMMAND} &> /dev/null; then output success; else output failure; fi
	done

	# Cleanup old kernels if possible (only with yum-utils installed)
	if hash package-cleanup; then
		local COMMAND="package-cleanup -y --oldkernels --count=2"
		output leadup "${COMMAND}"
		if ${COMMAND} &> /dev/null; then output success; else output failure; fi
	fi

	# Raspberry Pi firmware update
	if hash rpi-update; then
		local COMMAND="rpi-update"
		output leadup "${COMMAND}"
		if ${COMMAND} &> /dev/null; then output success; else output failure; fi
	fi

	# Update kdm-bash-env from Git
	if hash _kdm_pull; then
		local COMMAND="kdm-pull"
		output leadup "${COMMAND}"
		# Redefine this because it's not really real
		if _kdm_pull &> /dev/null; then output success; else output failure; fi
	fi

	# Check for npm, if it exists, update npm packages
	if hash npm; then
		# Loop npm update until it's fully updated, up to 5 times
		local COMMAND="npm -g update"

		local NPM_UPDATE_COUNT="1"
		while [[ "${NPM_UPDATE_COUNT}" -le "5" ]]; do
			output leadup "${COMMAND} (loop #${NPM_UPDATE_COUNT})"
			if ${COMMAND} &> /dev/null; then output success; else output failure; fi

			# Increment loop counter
			((NPM_UPDATE_COUNT++))
		done
	fi

	# Check for ncu, if it exists, REALLY update npm packages
	if hash ncu; then
		local COMMAND="ncu -g -t"
		output leadup "${COMMAND}"
		local ARRAY_NPM_PACKAGES=($(${COMMAND} 2> /dev/null | sed '/^\s*$/d' | awk '$0 !~ /^All/ {print $1}'))
		output success

		# Perform update commands
		for NPM_PACKAGE in "${ARRAY_NPM_PACKAGES[@]}"; do
			local COMMAND="npm -g install ${NPM_PACKAGE}"
			output leadup "${COMMAND}"
			if ${COMMAND} &> /dev/null; then output success; else output failure; fi
		done
	fi

	# Check for python-pip, if it exists, update python-pip packages
	if hash pip; then
		# Array of pip packages to update, with pip and setuptools being first
		local COMMAND="pip list -o"
		output leadup "${COMMAND}"
		local ARRAY_PIP_PACKAGES=(pip setuptools $(pip list -o | awk '$0 !~ /pip|setuptools/ {print $1}'))
		output success

		# Perform update commands
		for PIP_PACKAGE in "${ARRAY_PIP_PACKAGES[@]}"; do
			local COMMAND="pip install --upgrade ${PIP_PACKAGE}"
			output leadup "${COMMAND}"
			if ${COMMAND} &> /dev/null; then output success; else output failure; fi
		done
	fi

	# Check for python-pip2, if it exists, update python-pip2 packages
	if hash pip2; then
		# Array of pip2 packages to update, with pip2 and setuptools being first
		local COMMAND="pip2 list -o"
		output leadup "${COMMAND}"
		local ARRAY_PIP_PACKAGES=(pip setuptools $(pip2 list -o | awk '$0 !~ /pip|setuptools/ {print $1}'))
		output success

		# Perform update commands
		for PIP_PACKAGE in "${ARRAY_PIP_PACKAGES[@]}"; do
			local COMMAND="pip2 install --upgrade ${PIP_PACKAGE}"
			output leadup "${COMMAND}"
			if ${COMMAND} &> /dev/null; then output success; else output failure; fi
		done
	fi

	# Check for python-pip3, if it exists, update python-pip3 packages
	if hash pip3; then
		# Array of pip3 packages to update, with pip3 and setuptools being first
		local COMMAND="pip3 list -o"
		output leadup "${COMMAND}"
		local ARRAY_PIP_PACKAGES=(pip setuptools $(pip3 list -o | awk '$0 !~ /pip|setuptools/ {print $1}'))
		output success

		# Perform update commands
		for PIP_PACKAGE in "${ARRAY_PIP_PACKAGES[@]}"; do
			local COMMAND="pip3 install --upgrade ${PIP_PACKAGE}"
			output leadup "${COMMAND}"
			if ${COMMAND} &> /dev/null; then output success; else output failure; fi
		done
	fi

	# rubygems update
	if hash update_rubygems; then
		# Array of update commands
		unset ARRAY_COMMANDS
		local ARRAY_COMMANDS[0]="update_rubygems"
		local ARRAY_COMMANDS[1]="gem update  --silent --system"
		local ARRAY_COMMANDS[2]="gem update  --silent"
		local ARRAY_COMMANDS[3]="gem cleanup --silent"

		# Perform update commands
		for COMMAND in "${ARRAY_COMMANDS[@]}"; do
			output leadup "${COMMAND}"
			if ${COMMAND} &> /dev/null; then output success; else output failure; fi
		done
	fi

	output green "update-all complete"
	return 0
}

# Update just CPAN packages
_update_cpan() {
	# Check 1st argument
	if [[ "${1}" != "-y" ]]; then
		# Check if they're sure
		read -r -p "Are you sure? [Y/n] " UPDATE_YN
		echo
		[[ "${UPDATE_YN}" == [Nn] ]] && output cyan "update-cpan not performed" && return
	fi

	# Bounce if we couldn't find a supported package manager
	if [[ -z "${PACKAGE_MANAGER}" ]]; then
		output error "Could not detect package manager"
		return 1
	fi

	# Install CPAN if missing
	if ! hash cpan; then
		local COMMAND="${PACKAGE_MANAGER} -y install perl-CPAN perl-App-cpanminus cpanminus"
		output leadup "${COMMAND}"
		if ${COMMAND} &> /dev/null; then output success; else output failure; fi
	fi

	# Update CPAN itself, and YAML
	unset ARRAY_COMMANDS
	local ARRAY_COMMANDS[0]="cpan CPAN"
	local ARRAY_COMMANDS[1]="cpan YAML"
	for COMMAND in "${ARRAY_COMMANDS[@]}"; do
		output leadup "${COMMAND}"
		if ${COMMAND} &> /dev/null; then output success; else output failure; fi
	done

	# Check for cpanm, install if missing
	if ! hash cpanm; then
		local ARRAY_COMMANDS[0]="sudo ${PACKAGE_MANAGER} -y install cpanminus"
		local ARRAY_COMMANDS[1]="cpan App::cpanminus"
		for COMMAND in "${ARRAY_COMMANDS[@]}"; do
			output leadup "${COMMAND}"
			if ${COMMAND} &> /dev/null; then output success; else output failure; fi
		done
	fi

	# Check for cpan-outdated, install if missing
	if ! hash cpan-outdated; then
		local COMMAND="cpan App::cpanoutdated"
		output leadup "${COMMAND}"
		if ${COMMAND} &> /dev/null; then output success; else output failure; fi
	fi

	# Check for cpanm and cpanm-outdated again
	if ! hash cpanm && hash cpan-outdated; then
		output error "cpanminus and cpan-outdated could not be found"
		return 1
	fi

	# Update outdated CPAN modules in packages
	local COMMAND="cpan-outdated -p | cpanm"
	output leadup "${COMMAND}"
	# Custom due to command pipe
	if cpan-outdated -p | cpanm &> /dev/null; then output success; else output failure; fi

	# Update outdated CPAN modules
	local COMMAND="cpan-outdated | cpanm"
	output leadup "${COMMAND}"
	# Custom due to command pipe
	if cpan-outdated | cpanm &> /dev/null; then output success; else output failure; fi

	output green "update-cpan complete"
	return 0
}

#### Functions: Updates ==final ####


#### Functions: macOS-only (regardless of GNU conversion) ==start ####

if [[ "${UNAME_KERNEL_NAME}" == "Darwin" ]]; then
	# Function aliases
	alias macos-hostname='_macos_hostname'
	alias macos-itunes='_macos_itunes'
	alias macos-notify='_macos_notify'
	alias macos-repair-office='_macos_repair_office'
	alias macos-volume='_macos_volume'

	# Hostname change function
	_macos_hostname() {
		local USAGE_STRING="macos-hostname <new hostname>"
		[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

		sudo scutil --set LocalHostName "${1%%.*}"
		sudo scutil --set ComputerName  "${1}"
		sudo scutil --set HostName      "${1}"

		output green "Hostname set to '${1}'"
	}

	# iTunes control
	_macos_itunes() {
		# Declare vars as local
		local ARRAY_USAGE_OPTIONS ITUNES_ALBUM ITUNES_ARTIST ITUNES_NAME USAGE_OPTIONS_STRING USAGE_STRING

		# Array of options
		ARRAY_USAGE_OPTIONS=(
		pause
		next
		prev
		)

		# Create variable of pipe-separated options from array
		USAGE_OPTIONS_STRING="$(IFS=$'|'; echo "${ARRAY_USAGE_OPTIONS[*]}")"

		USAGE_STRING="macos-itunes <${USAGE_OPTIONS_STRING}>"
		[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

		case "${1}" in
			pause)
				osascript -e 'tell application "iTunes"' -e 'playpause' -e 'end tell'
				output green "Playback toggled"
				;;
			play)
				osascript -e 'tell application "iTunes"' -e 'playpause' -e 'end tell'
				output green "Playback toggled"
				;;
			next)
				osascript -e 'tell application "iTunes"' -e 'next track' -e 'end tell'
				output green "Skipped to next track"
				;;
			prev)
				osascript -e 'tell application "iTunes"' -e 'previous track' -e 'end tell'
				output green "Skipped to previous track"
				;;
		esac

		ITUNES_NAME="$(  osascript -e 'tell application "iTunes"' -e 'get name of current track'   -e 'end tell')"
		ITUNES_ARTIST="$(osascript -e 'tell application "iTunes"' -e 'get artist of current track' -e 'end tell')"
		ITUNES_ALBUM="$( osascript -e 'tell application "iTunes"' -e 'get album of current track'  -e 'end tell')"
		echo

		output orange "--= Currently playing =--"
		echo

		output purple "  Name : '${ITUNES_NAME}'"
		output purple "Artist : '${ITUNES_ARTIST}'"
		output purple " Album : '${ITUNES_ALBUM}'"
	}

	# Volume config function
	_macos_volume() {
		# Declare vars as local
		local ARRAY_USAGE_OPTIONS USAGE_OPTIONS_STRING VOLUME_CLEAN VOLUME_CURRENT VOLUME_MUTE VOLUME_SOUND_EFFECT

		# Array of options
		ARRAY_USAGE_OPTIONS=(
		mute
		max
		up
		down
		'[0-100]'
		)

		# Create variable of pipe-separated options from array
		USAGE_OPTIONS_STRING="$(IFS=$'|'; echo "${ARRAY_USAGE_OPTIONS[*]}")"

		VOLUME_CURRENT="$(osascript -e 'output volume of (get volume settings)')"
		VOLUME_MUTE="$(   osascript -e 'get output muted of (get volume settings)')"
		VOLUME_SOUND_EFFECT="/System/Library/LoginPlugins/BezelServices.loginPlugin/Contents/Resources/volume.aiff"

		# Make sure it's doesn't have any missing values
		if [[ "${VOLUME_CURRENT}" == *"missing"* || "${VOLUME_MUTE}" == *"missing"* ]]; then
			output error "Unable to detect current volume"
			return
		fi

		if [[ -z "${1}" ]]; then
			output usage "macos-volume <${USAGE_OPTIONS_STRING}>"
			echo
			output green "Current volume : ${VOLUME_CURRENT}%"
			output green "Mute status    : ${VOLUME_MUTE}"
			return
		fi

		case "${1}" in
			mute)
				if [[ "${VOLUME_MUTE}" == "false" ]]; then
					osascript -e 'set volume with output muted'
					output red "Volume muted"
				else
					osascript -e 'set volume without output muted'
					output green "Volume unmuted"
				fi
				;;

			max)
				osascript -e 'set volume output volume 100'
				output green "Volume set to 100%"
				;;

			up)
				if [[ "${VOLUME_CURRENT}" -lt "95" ]]; then
					osascript -e "set volume output volume $((VOLUME_CURRENT+5))"
					output green "Volume set to $((VOLUME_CURRENT+5))%"
				elif [[ "${VOLUME_CURRENT}" -ge "95" && "${VOLUME_CURRENT}" -lt "100" ]]; then
					osascript -e 'set volume output volume 100'
					output green "Volume set to 100%"
				else
					output red "Volume is already set to ${VOLUME_CURRENT}%"
				fi
				;;

			down)
				if [[ "${VOLUME_CURRENT}" -gt "5" ]]; then
					osascript -e "set volume output volume $((VOLUME_CURRENT-5))"
					output green "Volume set to $((VOLUME_CURRENT-5))%"
				elif [[ "${VOLUME_CURRENT}" -le "5" && "${VOLUME_CURRENT}" -gt "0" ]]; then
					osascript -e 'set volume output volume 0'
					output green "Volume set to 0%"
				else
					output red "Volume is already set to ${VOLUME_CURRENT}%"
				fi
				;;

			*)
				VOLUME_CLEAN="${1//[^0-9]}"
				if [[ "${#VOLUME_CLEAN}" == "0" || "${#VOLUME_CLEAN}" -gt "100" ]]; then
					output red "Invalid volume entered"
				else
					osascript -e "set volume output volume ${VOLUME_CLEAN}"
					output green "Volume set to ${VOLUME_CLEAN}%"
				fi
				;;
		esac

		# Play volume change sound effect
		{
			afplay "${VOLUME_SOUND_EFFECT}" & disown
		} &> /dev/null
	}

	# Reset all Office Mac 2011 files
	_macos_repair_office() {
		# Declare vars as local
		local ARRAY_RESET_FILES PTH_AS PTH_CHE PTH_LIB PTH_PRF RESET_YN

		# Check if they're sure
		read -r -p "Are you sure? [Y/n] " RESET_YN
		echo
		[[ "${RESET_YN}" == [Nn] ]] && output purple "No changes" && return

		PTH_LIB="${HOME}/Library"
		PTH_AS="${PTH_LIB}/Application Support"
		PTH_CHE="${PTH_LIB}/Caches"
		PTH_PRF="${PTH_LIB}/Preferences"

		ARRAY_RESET_FILES=(
		${HOME}/Documents/Microsoft\ User\ Data
		${PTH_AS}/CrashReporter/Microsoft*
		${PTH_AS}/Microsoft
		${PTH_AS}/com.apple.sharedfilelist/com.apple.LSSharedFileList.ApplicationRecentDocuments/com.microsoft.*
		${PTH_CHE}/Microsoft
		${PTH_CHE}/com.apple.helpd/Generated/com.microsoft.*
		${PTH_CHE}/com.apple.helpd/SDMHelpData/Other/English/HelpSDMIndexFile/com.microsoft.*
		${PTH_CHE}/com.microsoft.*
		${PTH_PRF}/Microsoft
		${PTH_PRF}/com.microsoft.*
		)

		output red "Resetting all Microsoft Office data"
		rm -rf "${ARRAY_RESET_FILES[@]}"

		defaults delete com.microsoft.Outlook &> /dev/null
		killall cfprefsd                      &> /dev/null

		output green "Complete; you should reboot, preferably"
	}

	_macos_notify() {
		local NOTIFY_TITLE="${1}"
		local NOTIFY_MESSAGE="${2}"
		local NOTIFY_SUBTITLE="${3}"

		local USAGE_STRING="macos-notify <title> <message> [<subtitle>]"
		[[ -z "${NOTIFY_TITLE}" || -z "${NOTIFY_MESSAGE}" ]] && output usage "${USAGE_STRING}" && return

		# Add subtitle to osascript string if present
		[[ "${NOTIFY_SUBTITLE}" ]] && local NOTIFY_SUBTITLE="subtitle \"${NOTIFY_SUBTITLE}\""

		osascript -e "display notification \"${NOTIFY_MESSAGE}\" with title \"${NOTIFY_TITLE}\" ${NOTIFY_SUBTITLE}"
	}

fi

#### Functions: macOS-only (regardless of GNU conversion) ==start ####


#### Functions: Linux-only ==start ####

if [[ "${UNAME_KERNEL_NAME}" == "Linux" ]]; then
	# Function aliases
	alias kvm-destroy-all='_kvm_destroy_all'
	alias kvm-running='_kvm_running'
	alias kvm-shutdown-all='_kvm_shutdown_all'
	alias kvm-start-all='_kvm_start_all'
	alias kvm-undefine='_kvm_undefine'
	alias kvm-watch='_kvm_watch'
	alias sys-restart='_sys_restart'

	# systemctl no-pager
	hash systemctl && alias systemctl='systemctl --no-pager'

	# Restart with systemctl
	_sys_restart() {
		local USAGE_STRING="sys-restart <process name>"
		[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

		! hash systemctl && output error "systemctl not available" && return

		output yellow "Stopping '${1}'"
		systemctl stop "${1}"

		output yellow "Sleeping"
		sleep 1

		output yellow "Starting '${1}'"
		systemctl start "${1}"

		echo
		systemctl status "${1}"
	}

	# Network config information
	_net_info() {
		if hash hostname; then
			output keyval "hostname"    "$(hostname)"
			output keyval "hostname -s" "$(hostname -s)"
			output keyval "hostname -d" "$(hostname -d)"
			output keyval "hostname -f" "$(hostname -f)"
		fi

		if [[ -s /etc/resolv.conf ]]; then
			output orange "--= resolv.conf =--"
			echo

			grep -Ev '^#' /etc/resolv.conf
		fi

		if hash ip; then
			output orange "--= ip route show =--"
			echo

			ip route show
			echo

			output orange "--= ip addr =--"
			echo

			ip addr show "${DEFROUTE_NIC}"
			echo
		fi
	}

	# List running VMs
	_kvm_running() {
		# Declare vars as local
		local ARRAY_RUNNING

		ARRAY_RUNNING=($(virsh list | awk '/running/ {print $2}'))
		[[ -z "${ARRAY_RUNNING[0]}" ]] && output purple "No VMs running" && return 0

		output orange "--= Running VMs =--"
		echo

		for VM in "${ARRAY_RUNNING[@]}"; do
			output green "${VM}"
		done
	}

	# Watch until all VMs are shutdown
	_kvm_watch() {
		local KVM_COUNTER="0"

		while true; do
			local ARRAY_WATCH=($(virsh list | awk '/running/ {print $2}'))
			local VM_COUNT="${#ARRAY_WATCH[@]}"

			[[ -z "${ARRAY_WATCH[0]}" ]] && output green "No VMs running" && break

			echo -en "${VM_COUNT} VMs ${C_GRN}running${C_RST}. ${KVM_COUNTER} sec elapsed     \r"

			sleep 1
			local KVM_COUNTER=$((KVM_COUNTER+1))
		done
	}

	# Undefine VMs based on a search string
	_kvm_undefine() {
		local USAGE_STRING="kvm-undefine <search string>"
		[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return

		local ARRAY_UNDEFINE=($(virsh list --all | awk '/'"${1}"'/ {print $2}'))
		[[ -z "${ARRAY_UNDEFINE[0]}" ]] && output yellow "No VMs running matching search string '${1}'" && return 0

		output purple "These VMs will be undefined:"; echo
		for VM in "${ARRAY_UNDEFINE[@]}"; do
			output red "${VM}"
		done
		echo

		read -r -p "Are you sure? [Y/n] " UNDEFINE_YN
		echo
		[[ "${UNDEFINE_YN}" == [Nn] ]] && output purple "No VMs undefined" && return 1

		for VM in "${ARRAY_UNDEFINE[@]}"; do
			output purple "Undefining '${VM}'"
			virsh undefine "${VM}"
		done
		echo
	}

	# Destroy all VMs
	_kvm_destroy_all() {
		local ARRAY_DESTROY=($(virsh list | awk '/running/ {print $2}'))
		[[ -z "${ARRAY_DESTROY[0]}" ]] && output purple "No VMs running" && return 0

		output purple "These VMs will be destroyed:"; echo
		for VM in "${ARRAY_DESTROY[@]}"; do
			output red "${VM}"
		done
		echo

		read -r -p "Are you sure? [Y/n] " DESTROY_YN
		echo
		[[ "${DESTROY_YN}" == [Nn] ]] && output purple "No VMs destroyed" && return 1

		for VM in "${ARRAY_DESTROY[@]}"; do
			output red "Destroying '${VM}'"
			virsh destroy "${VM}"
		done
		echo
	}

	# Shutdown all VMs
	_kvm_shutdown_all() {
		local ARRAY_SHUTDOWN=($(virsh list | awk '/running/ {print $2}'))
		[[ -z "${ARRAY_DESTROY[0]}" ]] && output purple "No VMs running" && return 0

		output purple "These VMs will be shutdown:"; echo
		for VM in "${ARRAY_SHUTDOWN[@]}"; do
			output red "${VM}"
		done
		echo

		read -r -p "Are you sure? [Y/n] " SHUTDOWN_YN
		echo
		[[ "${SHUTDOWN_YN}" == [Nn] ]] && output purple "No VMs shutdown" && return 1

		for VM in "${ARRAY_SHUTDOWN[@]}"; do
			output yellow "Shutting down VM '${VM}'"
			virsh shutdown "${VM}"
		done
		echo
	}

	# Start all VMs
	_kvm_start_all() {
		local ARRAY_START=($(virsh list --all | awk '/shut off/ {print $2}' | sed -e '/Name/d' -e '/^$/d'))
		[[ -z "${ARRAY_START[0]}" ]] && output purple "No shut off VMs" && return 0

		output purple "These VMs will be started:"; echo
		for VM in "${ARRAY_START[@]}"; do
			output green "${VM}"
		done
		echo

		read -r -p "Are you sure? [Y/n] " START_YN
		echo
		[[ "${START_YN}" == [Nn] ]] && output purple "No VMs started" && return 1

		for VM in "${ARRAY_START[@]}"; do
			output green "Starting VM '${VM}'"
			virsh start "${VM}"
		done
		echo
	}

fi

#### Functions: Linux-only ==final ####


#### Functions: Auto-sudo ==start ####

# Generate auto-sudo aliases
_auto_sudo_generate() {
	# Clear sudo cache file
	: > "${BASH_ENV_FILE_SUDOCACHE}"

	# Process auto-sudo-alias generation, output to sudo cache file
	for CMD in "${ARRAY_SUDO[@]}"; do
		# If it's installed, add sudo
		hash "${CMD}" && echo "alias ${CMD}='sudo ${CMD}'" >> "${BASH_ENV_FILE_SUDOCACHE}"
	done
}

# Configure auto-sudo aliases
_auto_sudo_setup() {
	# First check if we're root. If so, we don't need any of this
	[[ "${UID}" == "0" ]] && return

	# If we're on macOS, add the macOS commands to the base array
	# If we're on Linux, add the Linux commands to the base array
	case "${UNAME_KERNEL_NAME}" in
		Darwin) ARRAY_SUDO+=(${ARRAY_SUDO_MACOS[@]}) ;;
		Linux)  ARRAY_SUDO+=(${ARRAY_SUDO_LINUX[@]}) ;;
	esac

	# Regenerate sudocache file if empty
	[[ ! -s "${BASH_ENV_FILE_SUDOCACHE}" ]] && _auto_sudo_generate

	# Declare vars as local
	local SUDOCACHE_AGE SUDOCACHE_TIME

	# Determine age of sudocache file
	if [[ "${MACOS_GNU}" || "${UNAME_KERNEL_NAME}" == "Linux" ]]; then
		SUDOCACHE_TIME=$(stat -c '%Y' "${BASH_ENV_FILE_SUDOCACHE}")
	else
		SUDOCACHE_TIME=$(stat -f '%m' "${BASH_ENV_FILE_SUDOCACHE}")
	fi

	let SUDOCACHE_AGE=$(($(date +%s)-SUDOCACHE_TIME))

	# Regenerate sudocache file if older than 1 day
	[[ "${SUDOCACHE_AGE}" -ge "86400" ]] && _auto_sudo_generate

	# Source sudocache file
	# shellcheck source=.kdm/sudocache
	. "${BASH_ENV_FILE_SUDOCACHE}"
}

#### Functions: Auto-sudo ==final ####


#### Aliases: Global ==start ####

# Pre-sorted environment variables
alias env-sort='env | sort -h'

# Newline after screen clear
alias clear='clear; echo'
alias c='clear'

# Safety first on file operations
alias rm='rm -i'
alias cp='cp -iv'
alias mv='mv -i'
alias mkdir='mkdir -p'


# Diff enable auto color
DIFF_VERSION="$(diff -v | grep -Eo '[3-9]\.[0-9]$')"
if [[ "${DIFF_VERSION/\./}" -ge "34" ]]; then
	alias diff='diff --color=auto'
fi

# Custom diff:
# Tabsize : 2 columns
# Ignore tab expansion
# Ignore trailing space
# Ignore whitespace changes
# Ignore blank lines
alias kdiff='diff --tabsize=2 --ignore-tab-expansion --ignore-trailing-space --ignore-space-change --ignore-blank-lines'


# File list aliases
alias l.=' ls -d .*  2> /dev/null'
alias l1=' ls -Fh1   2> /dev/null'
alias l='  ls -CF    2> /dev/null'
alias la=' ls -A     2> /dev/null'
alias ll.='ls -dl .* 2> /dev/null'
alias ll=' ls -Fhl   2> /dev/null'
alias lld='ls -Fhld  2> /dev/null'
alias lll='ls -Fahl  2> /dev/null'

# Quick up-directory-n-list
alias ..='cd ..; ll'

# Downloads and Desktop folder alases
[[ -d ${HOME}/Desktop   ]] && alias dt="cd \${HOME}/Desktop"
[[ -d ${HOME}/Downloads ]] && alias dl="cd \${HOME}/Downloads"
[[ -d ${HOME}/Documents ]] && alias dc="cd \${HOME}/Documents"

# If it has dnsmasq
[[ -f "/etc/dnsmasq.conf" ]] && alias config-dnsmasq='vim /etc/dnsmasq.conf'
[[ -d "/var/log/dnsmasq"  ]] && alias log-dnsmasq='cd /var/log/dnsmasq'

# If it has squid
[[ -d "/etc/squid"     ]] && alias config-squid='cd /etc/squid'
[[ -d "/var/log/squid" ]] && alias log-squid='cd /var/log/squid'

# If it has apache2/httpd
[[ -d "/etc/apache2"     ]] && alias config-apache2='cd /etc/apache2'
[[ -d "/var/log/apache2" ]] && alias log-apache2='cd /var/log/apache2'
[[ -d "/etc/httpd"       ]] && alias config-httpd='cd /etc/httpd'
[[ -d "/var/log/httpd"   ]] && alias log-httpd='cd /var/log/httpd'

# If it has samba
[[ -d "/etc/samba"     ]] && alias config-samba='cd /etc/samba'
[[ -d "/var/log/samba" ]] && alias log-samba='cd /var/log/samba'

# If it has yum
[[ -d "/etc/yum.repos.d" ]] && alias config-yumrepos='cd /etc/yum.repos.d'

# If it has libvirt
[[ -d "/var/lib/libvirt" ]] && alias config-libvirt='cd /var/lib/libvirt'
[[ -d "/var/log/libvirt" ]] && alias log-libvirt='cd /var/log/libvirt'

# Typo aliases
alias bim='vim'
alias cim='vim'
alias ehco='echo'
alias grpe='grep'
alias kk='ll'
alias namp='nmap'
alias pign='ping'
alias tial='tail'

# Alias to pass thru the 16mcolor hack over SSH
# [[ "${TERM}" == "xterm-16mcolor" ]] && alias ssh="TERM=${TERM} ssh"

# If it has nmap binary:
# only open ports, grepable output, aggressive and verbose aliases
if hash nmap; then
	# nmap needs sudo if not root
	# First, add one for not aggressive one (but still verbose)
	if [[ "${UID}" != "0" ]]; then
		alias nmap='sudo nmap --open'
		# nmap-v for very verbose scan
		alias nmap-v='sudo nmap -vv --open'
		# nmap-a for aggressive scripting scan
		alias nmap-a='sudo nmap -vv -A --open'
	else
		# already root, no need for sudo
		alias nmap='nmap --open'
		# nmap-v for very verbose scan
		alias nmap-v='nmap -vv --open'
		# nmap-a for aggressive scripting scan
		alias nmap-a='nmap -vv -A --open'
	fi
fi

# ping/noping command tweaks
# ping-slow : normal (1.0 second interval)
#      ping : fast   (0.5 second interval)
# ping-fast : faster (0.1 second interval)
alias ping='     ping -i 0.5'
alias ping-fast='ping -i 0.1'
alias ping-slow='ping -i 1.0'

# noping commands, if noping is present
if hash noping; then
	# noping needs sudo if not root
	if [[ "${UID}" != "0" ]]; then
		alias noping='     sudo noping -i 0.5'
		alias noping-fast='sudo noping -i 0.1'
		alias noping-slow='sudo noping -i 1.0'
	else
		alias noping='     noping -i 0.5'
		alias noping-fast='noping -i 0.1'
		alias noping-slow='noping -i 1.0'
	fi
fi

# oping commands, if oping is present
if hash oping; then
	# oping needs sudo if not root
	if [[ "${UID}" != "0" ]]; then
		alias oping='     sudo oping -i 0.5'
		alias oping-fast='sudo oping -i 0.1'
		alias oping-slow='sudo oping -i 1.0'
	else
		alias oping='     oping -i 0.5'
		alias oping-fast='oping -i 0.1'
		alias oping-slow='oping -i 1.0'
	fi
fi

# Prettyprint+colorize various formats, if supporting binaries are installed
if hash pygmentize; then
	if hash json_reformat; then
		alias json-format='json_reformat | pygmentize -l json -f terminal256 -O style=monokai'
		alias format-json='json-format'
	fi
	if hash tidy; then
		alias html-format='tidy -i -w 200 -ashtml -utf8 2> /dev/null | pygmentize -l html -f terminal256 -O style=monokai'
		alias format-html='html-format'
	fi
	if hash xmllint; then
		alias xml-format='xmllint --format - 2> /dev/null | pygmentize -l xml -f terminal256 -O style=monokai'
		alias format-xml='xml-format'
	fi
fi

#### Aliases: Global ==final ####


#### Aliases: Linux or macOS (with GNU conversion) ==start ####

# shellcheck disable=SC2139
_alias_linux_macos_setup() {
	# grep/ls config
	#     in a terminal : always enable/use color
	# NOT in a terminal : disable color
	#
	# -s : suppress error messages
	GREP_BASE="grep --color=if-tty -s"

	alias grep=" ${GREP_BASE}"
	alias egrep="${GREP_BASE} -E"
	alias fgrep="${GREP_BASE} -F"
	alias igrep="${GREP_BASE} -i"
	alias rgrep="${GREP_BASE} -r"
	alias vgrep="${GREP_BASE} -v"

	if hash zgrep; then
		alias zgrep=" z${GREP_BASE}"
		alias zegrep="z${GREP_BASE} -E"
		alias zfgrep="z${GREP_BASE} -F"
		alias zigrep="z${GREP_BASE} -i"
		alias zrgrep="z${GREP_BASE} -r"
		alias zvgrep="z${GREP_BASE} -v"
	fi
	if hash xzgrep; then
		alias xzgrep=" xz${GREP_BASE}"
		alias xzegrep="xz${GREP_BASE} -E"
		alias xzfgrep="xz${GREP_BASE} -F"
		alias xzigrep="xz${GREP_BASE} -i"
		alias xzrgrep="xz${GREP_BASE} -r"
		alias xzvgrep="xz${GREP_BASE} -v"
	fi

	alias cgrep=' grep -s --color=always' # Force enable color
	alias ncgrep='grep -s --color=never'  # Force disable color

	alias ls="  ls --color=if-tty 2> /dev/null"
	alias cls=' ls --color=always 2> /dev/null' # Force enable color
	alias ncls='ls --color=never  2> /dev/null' # Force disable color

	unset CMD_COLOR
	unset GREP_BASE

	# Sort by IP address octets
	alias sort-ip='sort -t . -k 1,1n -k 2,2n -k 3,3n -k 4,4n'
}

if [[ "${MACOS_GNU}" || "${UNAME_KERNEL_NAME}" == "Linux" ]]; then
	_alias_linux_macos_setup
fi

#### Aliases: Linux or macOS (with GNU conversion) ==final ####


#### Aliases: macOS-only (without GNU conversion) ==start ####

if [[ "${UNAME_KERNEL_NAME}" == "Darwin" && -z "${MACOS_GNU}" ]]; then
	# Alias to make md5sum work like Linux
	alias md5sum='md5 -r'

	# Color ls output
	alias ls='ls -G 2> /dev/null'
fi

#### Aliases: macOS-only (without GNU conversion) ==final ####


#### Aliases: macOS-only (regardless of GNU conversion) ==start ####

if [[ "${UNAME_KERNEL_NAME}" == "Darwin" ]]; then
	# PING_WAIT for use in ping functions
	export PING_WAIT="-t 1"

	# EFI partition mount for disk0, disk1, and disk2
	[[ -b /dev/disk0s1 ]] && alias efi-mount-0='diskutil mount /dev/disk0s1; [[ -d /Volumes/EFI/EFI ]] && cd /Volumes/EFI/EFI'
	[[ -b /dev/disk1s1 ]] && alias efi-mount-1='diskutil mount /dev/disk1s1; [[ -d /Volumes/EFI/EFI ]] && cd /Volumes/EFI/EFI'
	[[ -b /dev/disk2s1 ]] && alias efi-mount-2='diskutil mount /dev/disk2s1; [[ -d /Volumes/EFI/EFI ]] && cd /Volumes/EFI/EFI'

	# Show listening ports a bit easier
	alias net-listening-ipv4="netstat -an | grep -E '^..p4.*.LISTEN' | sort"
	alias net-listening-ipv6="netstat -an | grep -E '^..p6.*.LISTEN' | sort"

	# Fake lspci
	if hash dspci && ! hash lspci; then alias lspci='dspci'; fi

	# Fake lsusb
	hash system_profiler && alias lsusb='system_profiler SPUSBDataType'

	# Clear font cache
	alias macos-repair-fontcache='sudo atsutil databases -remove'

	# Lock screen and screensaver shortcuts
	alias macos-screen-off='pmset displaysleepnow'
	alias macos-screen-lock='/System/Library/CoreServices/Menu\ Extras/User.menu/Contents/Resources/CGSession -suspend'
	alias macos-screen-saver='open -a ScreenSaverEngine'
	alias macos-sleep="osascript -e 'tell app \"System Events\" to sleep'"

	# El Capitan and up
	if [[ "${UNAME_KERNEL_RELEASE%%.*}" -ge "15" ]]; then
		# Enable and disable indexing
		alias macos-indexing-enable='sudo mdutil -a -i on'
		alias macos-indexing-disable='sudo mdutil -a -i off'

		# Flush DNS cache
		alias macos-repair-dns='sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder'
	else # Pre-El Capitan
		alias macos-repair-dns='sudo killall -HUP mDNSResponder'
		alias macos-repair-diskperms="sudo diskutil repairPermissions /; sudo chown -R \${USER} /usr/local"
	fi

	# Yosemite/El Capitan
	if [[ "${UNAME_KERNEL_RELEASE%%.*}" == "14" || "${UNAME_KERNEL_RELEASE%%.*}" == "15" ]]; then
		# Repair disk permissions
		alias macos-repair-diskperms="sudo repair_packages --repair --standard-pkgs /; sudo chown -R \${USER} /usr/local"
	fi
fi

#### Aliases: macOS-only (regardless of GNU conversion) ==final ####


#### Aliases: Linux-only ==start ####

if [[ "${UNAME_KERNEL_NAME}" == "Linux" ]]; then
	# PING_WAIT for use in ping functions
	export PING_WAIT="-W 1"

	# Clean up old kernels, I can never remember this one
	alias kernel-cleanup='package-cleanup -y --oldkernels --count=2'
fi

#### Aliases: Linux-only ==final ####

# Configure auto-sudo aliases
_auto_sudo_setup

# Configure PS1 prompt
_prompt_generate


# vim: set syntax=sh filetype=sh ts=2 sw=2 tw=0 noet :
