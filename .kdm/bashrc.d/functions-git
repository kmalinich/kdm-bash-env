# Functions: Git

[[ "${_}" != "${0}" && "${SOURCE_VERBOSE}" == "true" ]] && output keyval "Loaded" "${BASH_SOURCE[@]/$HOME\/\.kdm\//}"

# Show Git-related info
_g_gi() {
	# Declare vars as local
	local BRANCH COMMIT CONFIG DIR HASH RELEASE TAG TAGS TOP URL

	BRANCH="$(git symbolic-ref --short HEAD 2> /dev/null)"
	COMMIT="$(git rev-parse HEAD            2> /dev/null)"
	DIR="$(   git rev-parse --git-dir       2> /dev/null)"
	TOP="$(   git rev-parse --show-toplevel 2> /dev/null)"
	URL="$(   git config remote.origin.url  2> /dev/null)"

	[[ -z "${BRANCH}" ]] && output error "No branch detected" && return
	[[ -z "${COMMIT}" ]] && output error "No commit detected" && return
	[[ -z "${DIR}"    ]] && output error "No repo detected"   && return
	[[ -z "${TOP}"    ]] && output error "No toplvl detected" && return
	[[ -z "${URL}"    ]] && output error "No URL detected"    && return

	CONFIG="${TOP}/${DIR}/config"
	[[ ! -s "${CONFIG}" ]] && output error "No config data detected" && return

	output orange "---------------------= git info =---------------------"
	output keyval "    URL" "${URL}"
	output keyval " Branch" "${BRANCH}"
	output keyval "Top lvl" "${TOP/$HOME/\~}"
	output keyval " Config" "${CONFIG/$HOME/\~}"
	output keyval " Commit" "${COMMIT}"

	# Git tag-related data
	TAGS="$(git describe --tags 2> /dev/null)"

	if [[ "${TAGS}" ]]; then
		HASH=$(    echo "${TAGS##v}" | awk -F '-' '{print $3}')
		TAG=$(     echo "${TAGS##v}" | awk -F '-' '{print $1}')
		RELEASE="$(echo "${TAGS##v}" | awk -F '-' '{print $2}').git${HASH##g}"

		[[ "${TAGS}" ]] && output keyval "   Tags" "${TAGS}"
		[[ "${HASH}" ]] && output keyval "   Hash" "${HASH}"
		[[ "${TAG}"  ]] && output keyval "Version" "${TAG}"

		if [[ "${RELEASE}" && "${RELEASE}" != ".git" ]]; then
			output keyval "Release" "${RELEASE}"
		fi
	fi
	echo

	_g_gs
}

# Git command wrapper for formatted output
_g_wrapper() {
	# Declare vars as local
	local CMD_EXIT GIT_CMD TEMP_FILE

	[[ -z "${1}" ]] && output error "No command provided to _g_wrapper" && return 254
	GIT_CMD="${1}"

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git -c "color.${GIT_CMD}=always" "${GIT_CMD}" > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] ----------------= git ${GIT_CMD} =--------------------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null
	return ${CMD_EXIT}
}

# Git status
_g_gs() {
	_g_wrapper status
}

# Git fetch, git pull, git update-all-the-submodules-to-latest
_g_gsu() {
	# Declare vars as local
	local CMD_EXIT GIT_BRANCH TEMP_FILE

	GIT_BRANCH="$(git symbolic-ref --short HEAD)"
	[[ -z "${GIT_BRANCH}" ]] && output error "No branch detected" && return

	_g_wrapper fetch
	CMD_EXIT="${?}"
	[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}

	# Check if there is an update
	if [[ "$(git log "HEAD..origin/${GIT_BRANCH}" --oneline 2>&1)" ]]; then
		# Perform git pull
		_g_wrapper pull
		CMD_EXIT="${?}"
		[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}
	else
		output blue "No git update available"
		echo
	fi

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git -c color.submodule=always submodule foreach --recursive 'git checkout master; git fetch; git pull' > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] ----------= git submodule update =-------------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null
	[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}

	_g_gs
	CMD_EXIT="${?}"
	return ${CMD_EXIT}
}

# Git fetch, git pull
_g_gu() {
	# Declare vars as local
	local CMD_EXIT GIT_BRANCH TEMP_FILE

	GIT_BRANCH="$(git symbolic-ref --short HEAD)"
	[[ -z "${GIT_BRANCH}" ]] && output error "No branch detected" && return

	_g_wrapper fetch
	CMD_EXIT="${?}"
	[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}

	# Check if there is an update
	if [[ "$(git log "HEAD..origin/${GIT_BRANCH}" --oneline 2>&1)" ]]; then
		# Perform git pull
		_g_wrapper pull
		CMD_EXIT="${?}"
		[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}
	else
		output blue "No git update available"
		echo
	fi

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git -c color.submodule=always submodule update --init > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] ----------= git submodule update --init =-------------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null
	[[ "${CMD_EXIT}" != "0" ]] && return ${CMD_EXIT}

	_g_gs
	CMD_EXIT="${?}"
	return ${CMD_EXIT}
}

# Git commit all w/message
_g_gca() {
	# Declare vars as local
	local COMMIT_MSG CMD_EXIT GIT_BRANCH TEMP_FILE USAGE_STRING

	USAGE_STRING="g-gca <commit message>"
	[[ -z "${1}" ]] && output usage "${USAGE_STRING}" && return
	COMMIT_MSG="${1}"

	if git diff-index --quiet HEAD --; then
		output blue "No changes to commit"
		return 1
	fi

	output keyval "Committing changes, with message" "${COMMIT_MSG}"
	echo

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git -c color.commit=always commit -a -m "${COMMIT_MSG}" > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] -------= git commit -a -m '${COMMIT_MSG}' =-----------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null

	if [[ "${CMD_EXIT}" == "0" ]]; then
		_g_gs
		CMD_EXIT="${?}"
	fi

	return ${CMD_EXIT}
}

# Git push origin
_g_gpo() {
	# Declare vars as local
	local ARRAY_BRANCHES ARRAY_USAGE_OPTIONS BRANCHES_STRING CMD_EXIT SELECTED_BRANCH TEMP_FILE USAGE_OPTIONS_STRING

	# Create variable of pipe-separated options from array
	ARRAY_USAGE_OPTIONS=(c d t m p pp)
	USAGE_OPTIONS_STRING="$(IFS=$'|'; echo "${ARRAY_USAGE_OPTIONS[*]}")"

	# Array of branches
	ARRAY_BRANCHES=(
	current
	develop
	testing
	master
	production
	postprod
	)

	# Create variable of pipe-separated branches from array
	BRANCHES_STRING="$(IFS=$'|'; echo "${ARRAY_BRANCHES[*]}")"

	case "${1}" in
		c)
			SELECTED_BRANCH="$(git symbolic-ref --short HEAD 2> /dev/null)"
			[[ -z "${SELECTED_BRANCH}" ]] && output error "No branch detected" && return
			;;

		d) SELECTED_BRANCH="develop" ;;
		t) SELECTED_BRANCH="testing" ;;
		m) SELECTED_BRANCH="master" ;;
		p) SELECTED_BRANCH="production" ;;
		p) SELECTED_BRANCH="postprod" ;;
		*) output usage "g-gpo <${USAGE_OPTIONS_STRING}> <${BRANCHES_STRING}> <y>" && return ;;
	esac

	if [[ "$(git log '@{u}..' --oneline | wc -l)" == "0" ]]; then
		output blue "No changes to push"
		return 1
	fi

	output keyval "Pushing to branch" "${SELECTED_BRANCH}"
	echo

	if [[ "${2##\-}" != [Yy] ]]; then
		read -r -p "Continue? [Y/n] " GIT_PUSH_YN
		echo

		[[ "${GIT_PUSH_YN}" == [Nn] ]] && output red "Push cancelled" && return 254
	fi

	# Generate temp file for output (until I learn how to do it without that)
	TEMP_FILE="$(mktemp)"

	git push --verbose origin "${SELECTED_BRANCH}" > "${TEMP_FILE}" 2>&1
	CMD_EXIT="${?}"

	if [[ -s "${TEMP_FILE}" ]]; then
		output orange "[${CMD_EXIT}] ------= git push origin ${SELECTED_BRANCH} =----------"
		cat "${TEMP_FILE}"
		echo
	fi

	rm -rf "${TEMP_FILE}" &> /dev/null

	if [[ "${CMD_EXIT}" == "0" ]]; then
		_g_gs
		CMD_EXIT="${?}"
	fi

	return ${CMD_EXIT}
}

# vim: set syntax=sh filetype=sh ts=2 sw=2 tw=0 noet :
